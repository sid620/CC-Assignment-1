     1	This article describes how to connect a Commodore 64 compatible printer to
     2	an IBM PC compatible computer.  The information originally appeared in an
     3	article that I wrote for the Tech Forum section of the March 1995 issue of
     4	Nuts & Volts magazine.  This information may be used and distributed so
     5	long as proper credit is given to the author and Nuts & Volts magazine.
     6	Copyright (C) 1995 by John Keyerleber and Nuts & Volts Magazine.
     7	
     8	The problem with Commodore 64 compatible printers is that these devices use
     9	the Commodore synchronous serial interface to communicate with the C64.  An
    10	IBM PC compatible printer port is a parallel interface, however it is
    11	possible to use this parallel port to emulate the C64 serial interface by
    12	constructing a special cable and writing a little bit of software.
    13	
    14	The cable is used to connect the PC DB25 pin parallel printer port to the 6
    15	pin DIN serial port on the C64 compatible printer.  The parts needed are
    16	one DB25 male connector (Radio Shack #276-1429), one 6 pin DIN plug (RS
    17	#274-020), and some six conductor cable (RS #278-874 or equivalent).  Note
    18	that the cable length should be kept to less than six feet.  The wiring
    19	connections and signal descriptions for this cable are given as follows:
    20	
    21	Commodore 64 DIN plug pin:    Parallel printer DB25 connector pin:
    22	     1 (SRQ IN)                    2 (DATA0)
    23	     2 (GND)                  20 (GND)
    24	     3 (SER ATN)                   3 (DATA1)
    25	     4 (SER CLK)                   4 (DATA2)
    26	     5 (SER DAT)                   5 (DATA3) and 11 (BUSY)
    27	     6 (RST)                  6 (DATA4)
    28	
    29	The software uses the PC parallel port to emulate a C64 serial port.  The
    30	example program, C64.C (Listing 1), is written in Borland's Turbo C.  It
    31	reads input and sends each character to the printer.  It can be used as a
    32	filter in an MS-DOS command line pipe.  For example, DOS commands such as:
    33	dir | c64 would print a directory listing, or type a_file | c64 would print
    34	the contents of a file.
    35	
    36	I have also written an MS-DOS device driver which can be used to allow any
    37	PC application to print to a C64 compatible printer, and it supports
    38	multiple printers connected to a single PC parallel port.  The listing for
    39	this software is too lengthy to print, however I will make this software
    40	and assembled cables available to Commodore 64 enthusiasts for a nominal
    41	charge; just write me for details.  With these C64 compatible printers
    42	often selling for less than $25 at garage sales and flea markets, it's easy
    43	to add a couple of additional "scratch" printers to any PC system.
    44	
    45	John Keyerleber
    46	26300 Chardonview Drive
    47	Cleveland, OH  44143
    48	(216) 261-9676
    49	E-mail:  jkeyerleber@bailey.com
    50	
    51	Listing 1:
    52	
    53	#include <stdio.h>
    54	#include <ctype.h>
    55	#include <dos.h>
    56	
    57	#define   PORTADR   0x378     // LPT1=0x378, LPT2 = 0x278
    58	#define   PRINTADR  0x04      // C64 compatible printer address
    59	#define   SRQ       0x01      // C64 SRQ IN signal
    60	#define   ATN       0x02      // C64 ATN signal
    61	#define   CLK       0x04      // C64 CLK signal
    62	#define   DATOUT    0x08      // C64 DAT signal (output)
    63	#define   DATIN     0x80      // C64 DAT signal (input)
    64	#define   RST       0x10      // C64 RST signal
    65	
    66	// function prototypes
    67	void initc64(void);
    68	void putc64(unsigned char);
    69	void puts64(char *);
    70	void putbyte(unsigned char, unsigned char);
    71	
    72	// function main() loops to read input characters and send them to the printer
    73	void main(void)
    74	{
    75	     char buff[128], *ptr;
    76	
    77	     initc64();
    78	     while(fgets(buff, 80, stdin))
    79	     {
    80	          for(ptr = buff; *ptr; putc64(*ptr++));
    81	     }
    82	}
    83	
    84	// function init64() initializes the driver and the C64 compatible printer
    85	void initc64(void)
    86	{
    87	     // set initial port output value to all bits high
    88	     outportb(PORTADR, RST | SRQ | ATN | CLK | DATOUT);
    89	
    90	     // set interface to output
    91	     outportb(PORTADR + 2, 0x00);
    92	
    93	     // initialize printer: RST=0, then RST=1
    94	     outportb(PORTADR, SRQ | ATN | CLK | DATOUT);
    95	     delay(250);
    96	     outportb(PORTADR, RST | SRQ | ATN | CLK | DATOUT);
    97	     delay(2250);
    98	
    99	     // Set printer to listener: ATN and CLK low, printer will ACK with DAT low
   100	     outportb(PORTADR, RST | SRQ | DATOUT);
   101	     while(!(inportb(PORTADR + 1) & DATIN));
   102	
   103	     // Send printer address (currently set for address 4)
   104	     putbyte(0x20 | PRINTADR, 0);
   105	
   106	     // Send printer mode
   107	     putbyte(0x67, 0);
   108	}
   109	
   110	// function putc64() sends a byte of data (byteval) to the C64 compatible printer
   111	void putc64(unsigned char byteval)
   112	{
   113	     // Check for upper/lower case conversion
   114	     if (isalpha(byteval))
   115	     {
   116	          byteval = (isupper(byteval)) ? tolower(byteval) : toupper(byteval);
   117	     }
   118	     // Send character
   119	     putbyte(byteval, ATN);
   120	}
   121	
   122	// function putbyte clocks the actual byte to the C64 compatible printer bit by bit
   123	void putbyte(unsigned char byteval, unsigned char mode)
   124	{
   125	     register int bitloop;
   126	
   127	     // Set CLK high, printer will ACK with DAT high
   128	     outportb(PORTADR, RST | SRQ | CLK | DATOUT | mode);
   129	     while(inportb(PORTADR + 1) & DATIN);
   130	
   131	     // Loop to output bits of data
   132	     delay(1);
   133	     for (bitloop=0; bitloop<8; bitloop++)
   134	     {
   135	          outportb(PORTADR, RST | SRQ | ((byteval & 1) ? DATOUT : 0) | mode);
   136	          delay(1);
   137	          outportb(PORTADR, RST | SRQ | CLK | ((byteval & 1) ? DATOUT : 0) | mode);
   138	          delay(1);
   139	          byteval >>= 1;
   140	     }
   141	
   142	     // Set CLK low and DAT high for end of byte, printer will ACK with DAT low
   143	     outportb(PORTADR, RST | SRQ | DATOUT | mode);
   144	     while(!(inportb(PORTADR + 1) & DATIN));
   145	}
   146	
