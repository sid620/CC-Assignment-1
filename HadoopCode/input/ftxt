     1	"FTXT" IFF Formatted Text
     2	
     3	Date:	November 15, 1985
     4	From:	Steve Shaw and Jerry Morrison, Electronic Arts and 
     5		Bob "Kodiak" Burns, Commodore-Amiga
     6	Status:	Draft 2.6
     7	
     8	DRAFT                 DRAFT             DRAFT               
     9	DRAFT                 DRAFT		DRAFT	
    10	
    11	1. Introduction
    12	
    13	This memo is the IFF supplement for FORM FTXT. An FTXT is an IFF "data 
    14	section" or "FORM type" which can be an IFF file or a part of one containing 
    15	a stream of text plus optional formatting information."EA IFF 85" 
    16	is Electronic Arts' standard for interchange format files. (See the 
    17	IFF reference.)
    18	
    19	An FTXT is an archival and interchange representation designed for 
    20	three uses. The simplest use is for a "console device" or "glass teletype" 
    21	(the minimal 2-D text layout means): a stream of "graphic" ("printable") 
    22	characters plus positioning characters "space" ("SP") and line terminator 
    23	("LF"). This is not intended for cursor movements on a screen although 
    24	it does not conflict with standard cursor-moving characters. The second 
    25	use is text that has explicit formatting information (or "looks") 
    26	such as font family and size, typeface, etc. The third use is as the 
    27	lowest layer of a structured document that also has "inherited" styles 
    28	to implicitly control character looks. For that use, FORMs FTXT would 
    29	be embedded within a future document FORM type. The beauty of FTXT 
    30	is that these three uses are interchangeable, that is, a program written 
    31	for one purpose can read and write the others' files. So a word processor 
    32	does not have to write a separate plain text file to communicate with 
    33	other programs.
    34	
    35	Text is stored in one or more "CHRS" chunks inside an FTXT. Each CHRS 
    36	contains a stream of 8-bit text compatible with ISO and ANSI data 
    37	interchange standards. FTXT uses just the central character set from 
    38	the ISO/ANSI standards. (These two standards are henceforth called 
    39	"ISO/ANSI" as in "see the ISO/ANSI reference".)
    40	
    41	Since it's possible to extract just the text portions from future 
    42	document FORM types, programs can exchange data without having to 
    43	save both plain text and formatted text representations.
    44	
    45	Character looks are stored as embedded control sequences within CHRS 
    46	chunks. This document specifies which class of control sequences to 
    47	use: the CSI group. This document does not yet specify their meanings, 
    48	e.g. which one means "turn on italic face". Consult ISO/ANSI.
    49	
    50	Section 2 defines the chunk types character stream "CHRS" and font 
    51	specifier "FONS". These are the "standard" chunks. Specialized chunks 
    52	for private or future needs can be added later. Section 3 outlines 
    53	an FTXT reader program that strips a document down to plain unformatted 
    54	text. Appendix A is a code table for the 8-bit ISO/ANSI character 
    55	set used here. Appendix B is an example FTXT shown as a box diagram. 
    56	Appendix C is a racetrack diagram of the syntax of ISO/ANSI control 
    57	sequences.
    58	
    59	
    60	Reference:
    61	
    62	Amiga[tm] is a trademark of Commodore-Amiga, Inc.
    63	
    64	Electronic Arts[tm] is a trademark of Electronic Arts.
    65	
    66	IFF: "EA IFF 85" Standard for Interchange Format Files describes the 
    67	underlying conventions for all IFF files.
    68	
    69	ISO/ANSI: ISO/DIS 6429.2 and ANSI X3.64-1979. International Organization 
    70	for Standardization (ISO) and American National Standards Institute 
    71	(ANSI) data-interchange standards. The relevant parts of these two 
    72	standards documents are identical. ISO standard 2022 is also relevant.
    73	
    74	
    75	2. Standard Data and Property Chunks
    76	
    77	The main contents of a FORM FTXT is in its character stream "CHRS" 
    78	chunks. Formatting property chunks may also appear. The only formatting 
    79	property yet defined is "FONS", a font specifier. A FORM FTXT with 
    80	no CHRS represents an empty text stream. A FORM FTXT may contain nested 
    81	IFF FORMs, LISTs, or CATs, although a "stripping" reader (see section 
    82	3) will ignore them.
    83	
    84	Character Set
    85	
    86	FORM FTXT uses the core of the 8-bit character set defined by the 
    87	ISO/ANSI standards cited at the start of this document. (See Appendix 
    88	A for a character code table.) This character set is divided into 
    89	two "graphic" groups plus two "control" groups. Eight of the control 
    90	characters begin ISO/ANSI standard control sequences. (See "Control 
    91	Sequences", below.) Most control sequences and control characters 
    92	are reserved for future use and for compatibility with ISO/ANSI. Current 
    93	reader programs should skip them.
    94	
    95	%	C0 is the group of control characters in the range NUL (hex 
    96	0) through hex 1F. Of these, only LF (hex 0A) and ESC (hex 1B) are 
    97	significant. ESC begins a control sequence. LF is the line terminator, 
    98	meaning "go to the first horizontal position of the next line". All 
    99	other C0 characters are not used. In particular, CR (hex 0D) is not 
   100	recognized as a line terminator.
   101	
   102	%	G0 is the group of graphic characters in the range hex 20 through 
   103	hex 7F. SP (hex 20) is the space character. DEL (hex 7F) is the delete 
   104	character which is not used. The rest are the standard ASCII printable 
   105	characters "!" (hex 21) through "~" (hex 7E).
   106	
   107	%	C1 is the group of extended control characters in the range 
   108	hex 80 through hex 9F. Some of these begin control sequences. The 
   109	control sequence starting with CSI (hex 9B) is used for FTXT formatting. 
   110	All other control sequences and C1 control characters are unused.
   111	
   112	%	G1 is the group of extended graphic characters in the range 
   113	NBSP (hex A0) through "X" (hex FF). It is one of the alternate graphic 
   114	groups proposed for ISO/ANSI standardization.
   115	
   116	Control Sequences
   117	
   118	Eight of the control characters begin ISO/ANSI standard "control sequences" 
   119	(or "escape sequences"). These sequences are described below and diagrammed 
   120	in Appendix C.
   121	
   122	G0	::= (SP through DEL)
   123	G1	::= (NBSP through "X")
   124	
   125	ESC-Seq	::= ESC (SP through "/")* ("0" through "~")
   126	ShiftToG2	::= SS2 G0
   127	ShiftToG3	::= SS3 G0
   128	CSI-Seq	::= CSI (SP through "?")* ("@" through "~")
   129	DCS-Seq	::= (DCS | OSC | PM | APC) (SP through "~" | G1)* ST
   130	
   131	"ESC-Seq" is the control sequence ESC (hex 1B), followed by zero or 
   132	more characters in the range SP through "/S (hex 20 through hex 2F), 
   133	followed by a character in the range "0" through "~" (hex 30 through 
   134	hex 7E). These sequences are reserved for future use and should be 
   135	skipped by current FTXT reader programs.
   136	
   137	SS2 (hex 8E) and SS3 (hex 8F) shift the single following G0 character 
   138	into yet-to-be-defined graphic sets G2 and G3, respectively. These 
   139	sequences should not be used until the character sets G2 and G3 are 
   140	standardized. A reader may simply skip the SS2 or SS3 (taking the 
   141	following character as a corresponding G0 character) or replace the 
   142	two-character sequence with a character like "?" to mean "absent".
   143	
   144	FTXT uses "CSI-Seq" control sequences to store character formatting 
   145	(font selection by number, type face, and text size) and perhaps layout 
   146	information (position and rotation). "CSI-Seq" control sequences start 
   147	with CSI (the "control sequence introducer", hex 9B). Syntactically, 
   148	the sequence includes zero or more characters in the range SP through 
   149	"?" (hex 20 through hex 3F) and a concluding character in the range 
   150	"@" through "~" (hex 40 through hex 7E). These sequences may be skipped 
   151	by a minimal FTXT reader, i.e. one that ignores formatting information.
   152	
   153	Note: A future FTXT standardization document will explain the uses 
   154	of CSI-Seq sequences for setting character face (light weight vs. 
   155	medium vs. bold, italic vs. upright, height, pitch, position, and 
   156	rotation). For now, consult the ISO/ANSI references.
   157	
   158	"DCS-Seq" is the control sequences starting with DCS (hex 90), OSC 
   159	(hex 9D), PM (hex 9E), or APC (hex 9F), followed by zero or more characters 
   160	each of which is in the range SP through "~" (hex 20 through hex 7E) 
   161	or else a G1 character, and terminated by an ST (hex 9C). These sequences 
   162	are reserved for future use and should be skipped by current FTXT 
   163	reader programs.
   164	
   165	Data Chunk CHRS
   166	
   167	A CHRS chunk contains a sequence of 8-bit characters abiding by the 
   168	ISO/ANSI standards cited at the start of this document. This includes 
   169	the character set and control sequences as described above and summarized 
   170	in Appendicies A and C.
   171	
   172	A FORM FTXT may contain any number of CHRS chunks. Taken together, 
   173	they represent a single stream of textual information. That is, the 
   174	contents of CHRS chunks are effectively concatenated except that (1) 
   175	each control sequence must be completely within a single CHRS chunk, 
   176	and (2) any formatting property chunks appearing between two CHRS 
   177	chunks affects the formatting of the latter chunk's text. Any formatting 
   178	settings set by control sequences inside a CHRS carry over to the 
   179	next CHRS in the same FORM FTXT. All formatting properties stop at 
   180	the end of the FORM since IFF specifies that adjacent FORMs are independent 
   181	of each other (although not independent of any properties inherited 
   182	from an enclosing LIST or FORM).
   183	
   184	Property Chunk FONS
   185	
   186	The optional property "FONS" holds a FontSpecifier as defined in the 
   187	C declaration below. It assignes a font to a numbered "font register" 
   188	so it can be referenced by number within subsequent CHRS chunks. (This 
   189	function is not provided within the ISO and ANSI standards.) The font 
   190	specifier gives both a name and a description for the font so the 
   191	recipient program can do font substitution.
   192	
   193	By default, CHRS text uses font 1 until it selects another font. A 
   194	minimal text reader always uses font 1. If font 1 hasn't been specified, 
   195	the reader may use the local system font as font 1.
   196	
   197		typedef struct {
   198			UBYTE id;	
   199				/* 0 through 9 is a font id number referenced by an 
   200				 * SGR control sequence selective parameter of 10 
   201				 * through 19. Other values are reserved for future 
   202				 * standardization.	
   203				 */
   204			UBYTE pad1;   /* reserved for future use; store 0 here */
   205			UBYTE proportional;	
   206				/* proportional font? 0 = unknown, 1 = no, 2 = yes */ 
   207			UBYTE serif;		
   208				/* serif font? 0 = unknown, 1 = no, 2 = yes */
   209			char name[];	
   210				/* A NULL-terminated string naming preferred font. */
   211			} FontSpecifier;
   212		
   213	Fields are filed in the order shown. The UBYTE fields are byte-packed 
   214	(2 per 16-bit word). The field pad1 is reserved for future standardization. 
   215	Programs should store 0 there for now.
   216	
   217	The field proportional indicates if the desired font is proportional 
   218	width as opposed to fixed width. The field serif indicates if the 
   219	desired font is serif as opposed to sans serif. [Issue: Discuss font 
   220	substitution!]
   221	
   222	Future Properties
   223	
   224	New optional property chunks may be defined in the future to store 
   225	additional formatting information. They will be used to represent 
   226	formatting not encoded in standard ISO/ANSI control sequences and 
   227	for "inherited" formatting in structured documents. Text orientation 
   228	might be one example.
   229	
   230	Positioning Units
   231	
   232	Unless otherwise specified, position and size units used in FTXT formatting 
   233	properties and control sequences are in decipoints (720 decipoints/inch). 
   234	This is ANSI/ISO Positioning Unit Mode (PUM) 2. While a metric standard 
   235	might be nice, decipoints allow the existing U.S.A. typographic units 
   236	to be encoded easily, e.g. "12 points" is "120 decipoints".
   237	
   238	
   239	3. FTXT Stripper
   240	
   241	An FTXT reader program can read the text and ignore all formatting 
   242	and structural information in a document FORM that uses FORMs FTXT 
   243	for the leaf nodes. This amounts to stripping a document down to a 
   244	stream of plain text. It would do this by skipping over all chunks 
   245	except FTXT.CHRS (CHRS chunks found inside a FORM FTXT) and within 
   246	the FTXT.CHRS chunks skipping all control characters and control sequences. 
   247	(Appendix C diagrams this text scanner.) It may also read FTXT.FONS 
   248	chunks to find a description for font 1.
   249	
   250	Here's a Pascal-ish program for an FTXT stripper. Given a FORM (a 
   251	document of some kind), it scans for all FTXT.CHRS chunks. This would 
   252	likely be applied to the first FORM in an IFF file.
   253	
   254	PROCEDURE ReadFORM4CHRS();	{Read an IFF FORM for FTXT.CHRS chunks.}
   255	BEGIN
   256	IF the FORM's subtype = "FTXT"
   257		THEN ReadFTXT4CHRS()
   258		ELSE WHILE something left to read in the FORM DO BEGIN
   259				read the next chunk header;
   260				CASE the chunk's ID OF
   261					"LIST", "CAT ": ReadCAT4CHRS();
   262					"FORM": ReadFORM4CHRS();
   263					OTHERWISE skip the chunk's body;
   264					END
   265				END
   266	END;
   267	
   268	{Read a LIST or CAT for all FTXT.CHRS chunks.}
   269	PROCEDURE ReadCAT4CHRS();
   270		BEGIN
   271	WHILE something left to read in the LIST or CAT DO BEGIN
   272		read the next chunk header;
   273		CASE the chunk's ID OF
   274			"LIST", "CAT ": ReadCAT4CHRS();
   275			"FORM": ReadFORM4CHRS();
   276			"PROP": IF we're reading a LIST AND the PROP's subtype = 
   277	"FTXT"
   278						THEN read the PROP for "FONS" chunks;
   279			OTHERWISE error--malformed IFF file;
   280			END
   281		END
   282	END;
   283	
   284	PROCEDURE ReadFTXT4CHRS();	{Read a FORM FTXT for CHRS chunks.}
   285	BEGIN
   286	WHILE something left to read in the FORM FTXT DO BEGIN
   287		read the next chunk header;
   288		CASE the chunk's ID OF
   289			"CHRS": ReadCHRS();
   290			"FONS": BEGIN
   291				read the chunk's contents into a FontSpecifier variable;
   292				IF the font specifier's id = 1 THEN use this font;
   293				END;
   294			OTHERWISE skip the chunk's body;
   295			END
   296		END
   297	END;
   298	
   299	{Read an FTXT.CHRS. Skip all control sequences and unused control 
   300	chars.}
   301	PROCEDURE ReadCHRS();
   302	BEGIN
   303	WHILE something left to read in the CHRS chunk DO
   304		CASE read the next character OF
   305			LF:  start a new output line;
   306			ESC: SkipControl([' '..'/'], ['0'..'~']);
   307			IN [' '..'~'], IN [NBSP..'X']: output the character;
   308			SS2, SS3: ;	{Just handle the following G0 character 
   309					directly, ignoring the shift to G2 or G3.}
   310			CSI: SkipControl([' '..'?'], ['@'..'~']);
   311			DCS, OSC, PM, APC: SkipControl([' '..'~'] + [NBSP..'X'], [ST]);
   312			END
   313	END;
   314	
   315	{Skip a control sequence of the format (rSet)* (tSet), i.e. any number 
   316	of characters in the set rSet followed by a character in the set tSet.}
   317	PROCEDURE SkipControl(rSet, tSet);
   318	VAR c: CHAR;
   319	BEGIN
   320	REPEAT c := read the next character
   321		UNTIL c NOT IN rSet;
   322	IF c NOT IN tSet
   323		THEN put character c back into the input stream;
   324	END
   325	
   326	The following program is an optimized version of the above routines 
   327	ReadFORM4CHRS and ReadCAT4CHRS for the case where you're ignoring 
   328	fonts as well as formatting. It takes advantage of certain facts of 
   329	the IFF format to read a document FORM and its nested FORMs, LISTs, 
   330	and CATs without a stack. In other words, it's a hack that ignores 
   331	all fonts and faces to cheaply get to the plain text of the document.
   332	
   333	{Cheap scan of an IFF FORM for FTXT.CHRS chunks.}
   334	PROCEDURE ScanFORM4CHRS();
   335	BEGIN
   336	IF the document FORM's subtype = "FTXT"
   337		THEN ReadFTXT4CHRS()
   338		ELSE WHILE something left to read in the FORM DO BEGIN
   339			read the next chunk header;
   340			IF it's a group chunk (LIST, FORM, PROP, or CAT)
   341				THEN read its subtype ID;
   342			CASE the chunk's ID OF
   343				"LIST", "CAT ":;	{NOTE: See explanation below.*}
   344				"FORM": IF this FORM's subtype = "FTXT" THEN 
   345							ReadFTXT4CHRS()
   346					ELSE;	{NOTE: See explanation below.*}
   347				OTHERWISE skip the chunk's body;
   348				END
   349			END
   350	END;
   351	
   352	*Note: This implementation is subtle. After reading a group header 
   353	other than FORM FTXT it just continues reading. This amounts to reading 
   354	all the chunks inside that group as if they weren't nested in a group.
   355	
   356	
   357	Appendix A: Character Code Table
   358	
   359	This table corresponds to the ISO/DIS 6429.2 and ANSI X3.64-1979 8-bit 
   360	character set standards. Only the core character set of those standards 
   361	is used in FTXT.
   362	
   363	Two G1 characters aren't defined in the standards and are shown as 
   364	dark gray entries in this table. Light gray shading denotes control 
   365	characters. (DEL is a control character although it belongs to the 
   366	graphic group G0.) The following five rare G1 characters are left 
   367	blank in the table below due to limitations of available fonts: hex 
   368	A8, D0, DE, F0, and FE.
   369	
   370	
   371	
   372	   ISO/DIS 6429.2 and ANSI X3.64-1979 Character Code Table
   373	
   374	
   375	  (figure named "TextTable", viewable by ShowILBM or SeeILBM)
   376	
   377	
   378	[_____] [_______________________] [_____] [____________________________]
   379	Control   Grapic Group            Control   Graphic Group
   380	 Group        G0                   Group         G1
   381	  C0                                C1
   382	
   383	"NBSP" is a "non-breaking space"
   384	"SHY" is a "soft-hyphen"
   385	
   386	
   387	
   388	Appendix B. FTXT Example
   389	
   390	Here's a box diagram for a simple example: "The quick brown fox jumped.Four 
   391	score and seven", written in a proportional serif font named "Roman".
   392	
   393	
   394	      	+-----------------------------------+   
   395	      	|'FORM'		24070		    |     FORM  24070  ILBM
   396	      	+-----------------------------------+   
   397	      	|'ILBM'				    |     
   398	      	+-----------------------------------+   
   399	      	| +-------------------------------+ |   
   400	      	| | 'BMHD'	20		  | |     .BMHD  20
   401	      	| | 320, 200, 0, 0, 3, 0, 0, ...  | |   
   402	      	| | ------------------------------+ |   
   403	      	| | 'CMAP'	21	          | |     .CMAP  21
   404	      	| | 0, 0, 0; 32, 0, 0; 64,0,0; .. | |   
   405	      	| +-------------------------------+ |   
   406	      	| +-------------------------------+ |   
   407	      	| |'BODY'		24000     | |     .BODY  24000
   408	      	| |0, 0, 0, ...			  | |   
   409	      	| +-------------------------------+ |   
   410	      	+-----------------------------------+   
   411	
   412	The "0" after the CMAP chunk is a pad byte.
   413	
   414	
   415	
   416	
   417	Appendix B. Standards Committee
   418	
   419	The following people contributed to the design of this IFF standard:
   420	
   421	Bob "Kodiak" Burns, Commodore-Amiga
   422	R. J. Mical, Commodore-Amiga
   423	Jerry Morrison, Electronic Arts
   424	Greg Riker, Electronic Arts
   425	Steve Shaw, Electronic Arts
   426	Barry Walsh, Commodore-Amiga
   427	
   428	
   429	
   430	Appendix C. ISO/ANSI Control Sequences
   431	
   432	This is a racetrack diagram of the ISO/ANSI characters and control 
   433	sequences as used in FTXT CHRS chunks.
   434	
   435		line terminator   
   436	-----+-------------------> LF --------------------------------------->
   437	     |	ESC-Seq 
   438	     +-------------------> ESC ---+>----------------+--> 0 thru ~ --->
   439	     |				  |		    |
   440	     |				  +-- SP thru / <---+
   441	     |  printable
   442	     +---------------+---> SP thru ~ --+->--------------------------->
   443	     |		     |		       |
   444	     |		     +---> G1 -------->+
   445	     |  shift to G2				
   446	     +-------------------> SS2 ----> G0 ---> (produces a G2 character)
   447	     |  shift to G3				
   448	     +-------------------> SS3 ----> G0 ---> (produces a G3 character)
   449	     |	CSI-Seq 
   450	     +-------------------> CSI ---+>----------------+--> @ thru ~ --->
   451	     |				  |		    |
   452	     |				  +-- SP thru ? <---+
   453	     |	DCS-Seq 
   454	     +----------> DCS,OSC,PM,or APC --+>-------------+--+-> ST -+----> 
   455	     |				      |	             |  |       |
   456	     |				      +- SP thru ~ <-+  +-> G1 -+
   457	     |  discard
   458	     +----------> any other character ------------------------------->
   459	
   460	
   461	
   462	Of the various control sequences, only CSI-Seq is used for FTXT character 
   463	formatting information. The others are reserved for future use and 
   464	for compatibility with ISO/ANSI standards. Certain character sequences 
   465	are syntactically malformed, e.g. CSI followed by a C0, C1, or G1 
   466	character. Writer programs should not generate reserved or malformed 
   467	sequences and reader programs should skip them.
   468	
   469	Consult the ISO/ANSI standards for the meaning of the CSI-Seq control 
   470	sequences.
   471	
   472	The two character set shifts SS2 and SS3 may be used when the graphic 
   473	character groups G2 and G3 become standardized.
   474	
