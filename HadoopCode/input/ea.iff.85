     1	"EA IFF 85" Standard for Interchange Format Files
     2	
     3	Document Date:		January 14, 1985
     4	From:			Jerry Morrison, Electronic Arts
     5	Status of Standard:	Released and in use
     6	
     7	1. Introduction
     8	
     9	Standards are Good for Software Developers
    10	
    11	As home computer hardware evolves to better and better media machines, 
    12	the demand increases for higher quality, more detailed data. Data 
    13	development gets more expensive, requires more expertise and better 
    14	tools, and has to be shared across projects. Think about several ports 
    15	of a product on one CD-ROM with 500M Bytes of common data!
    16	
    17	Development tools need standard interchange file formats. Imagine 
    18	scanning in images of "player" shapes, moving them to a paint program 
    19	for editing, then incorporating them into a game. Or writing a theme 
    20	song with a Macintosh score editor and incorporating it into an Amiga 
    21	game. The data must at times be transformed, clipped, filled out, 
    22	and moved across machine kinds. Media projects will depend on data 
    23	transfer from graphic, music, sound effect, animation, and script 
    24	tools.
    25	
    26	Standards are Good for Software Users
    27	
    28	Customers should be able to move their own data between independently 
    29	developed software products. And they should be able to buy data libraries 
    30	usable across many such products. The types of data objects to exchange 
    31	are open-ended and include plain and formatted text, raster and structured 
    32	graphics, fonts, music, sound effects, musical instrument descriptions, 
    33	and animation.
    34	
    35	The problem with expedient file formats typically memory dumps is 
    36	that they're too provincial. By designing data for one particular 
    37	use (e.g. a screen snapshot), they preclude future expansion (would 
    38	you like a full page picture? a multi-page document?). In neglecting 
    39	the possibility that other programs might read their data, they fail 
    40	to save contextual information (how many bit planes? what resolution?). 
    41	Ignoring that other programs might create such files, they're intolerant 
    42	of extra data (texture palette for a picture editor), missing data 
    43	(no color map), or minor variations (smaller image). In practice, 
    44	a filed representation should rarely mirror an in-memory representation. 
    45	The former should be designed for longevity; the latter to optimize 
    46	the manipulations of a particular program. The same filed data will 
    47	be read into different memory formats by different programs.
    48	
    49	The IFF philosophy: "A little behind-the-scenes conversion when programs 
    50	read and write files is far better than NxM explicit conversion utilities 
    51	for highly specialized formats."
    52	
    53	So we need some standardization for data interchange among development 
    54	tools and products. The more developers that adopt a standard, the 
    55	better for all of us and our customers.
    56	
    57	Here is "EA IFF 1985"
    58	
    59	Here is our offering: Electronic Arts' IFF standard for Interchange 
    60	File Format. The full name is "EA IFF 1985". Alternatives and justifications 
    61	are included for certain choices. Public domain subroutine packages 
    62	and utility programs are available to make it easy to write and use 
    63	IFF-compatible programs.
    64	
    65	Part 1 introduces the standard. Part 2 presents its requirements and 
    66	background. Parts 3, 4, and 5 define the primitive data types, FORMs, 
    67	and LISTs, respectively, and how to define new high level types. Part 
    68	6 specifies the top level file structure. Appendix A is included for 
    69	quick reference and Appendix B names the committee responsible for 
    70	this standard.
    71	
    72	References
    73	
    74	American National Standard Additional Control Codes for Use with ASCII, 
    75	ANSI standard 3.64-1979 for an 8-bit character set. See also ISO standard 
    76	2022 and ISO/DIS standard 6429.2.
    77	
    78	Amiga[tm] is a trademark of Commodore-Amiga, Inc.
    79	
    80	C, A Reference Manual, Samuel P. Harbison and Guy L. Steele Jr., Tartan 
    81	Laboratories. Prentice-Hall, Englewood Cliffs, NJ, 1984.
    82	
    83	Compiler Construction, An Advanced Course, edited by F. L. Bauer and 
    84	J. Eickel (Springer-Verlag, 1976). This book is one of many sources 
    85	for information on recursive descent parsing.
    86	
    87	DIF Technical Specification (c)1981 by Software Arts, Inc. DIF[tm] is 
    88	the format for spreadsheet data interchange developed by Software 
    89	Arts, Inc.
    90	DIF[tm] is a trademark of Software Arts, Inc.
    91	
    92	Electronic Arts[tm] is a trademark of Electronic Arts.
    93	
    94	"FTXT" IFF Formatted Text, from Electronic Arts. IFF supplement document 
    95	for a text format.
    96	
    97	Inside Macintosh (c) 1982, 1983, 1984, 1985 Apple Computer, Inc., a 
    98	programmer's reference manual.
    99	Apple(R) is a trademark of Apple Computer, Inc.
   100	Macintosh[tm] is a trademark licensed to Apple Computer, Inc.
   101	
   102	"ILBM" IFF Interleaved Bitmap, from Electronic Arts. IFF supplement 
   103	document for a raster image format.
   104	
   105	M68000 16/32-Bit Microprocessor Programmer's Reference Manual(c) 1984, 
   106	1982, 1980, 1979 by Motorola, Inc.
   107	
   108	PostScript Language Manual (c) 1984 Adobe Systems Incorporated.
   109	PostScript[tm] is a trademark of Adobe Systems, Inc.
   110	Times and Helvetica(R) are trademarks of Allied Corporation.
   111	
   112	InterScript: A Proposal for a Standard for the Interchange of Editable 
   113	Documents (c)1984 Xerox Corporation.
   114	Introduction to InterScript (c) 1985 Xerox Corporation.
   115	
   116	
   117	
   118	2. Background for Designers
   119	
   120	Part 2 is about the background, requirements, and goals for the standard. 
   121	It's geared for people who want to design new types of IFF objects. 
   122	People just interested in using the standard may wish to skip this 
   123	part.
   124	
   125	What Do We Need?
   126	
   127	A standard should be long on prescription and short on overhead. It 
   128	should give lots of rules for designing programs and data files for 
   129	synergy. But neither the programs nor the files should cost too much 
   130	more than the expedient variety. While we're looking to a future with 
   131	CD-ROMs and perpendicular recording, the standard must work well on 
   132	floppy disks.
   133	
   134	For program portability, simplicity, and efficiency, formats should 
   135	be designed with more than one implementation style in mind. (In practice, 
   136	pure stream I/O is adequate although random access makes it easier 
   137	to write files.) It ought to be possible to read one of many objects 
   138	in a file without scanning all the preceding data. Some programs need 
   139	to read and play out their data in real time, so we need good compromises 
   140	between generality and efficiency.
   141	
   142	As much as we need standards, they can't hold up product schedules. 
   143	So we also need a kind of decentralized extensibility where any software 
   144	developer can define and refine new object types without some "standards 
   145	authority" in the loop. Developers must be able to extend existing 
   146	formats in a forward- and backward-compatible way. A central repository 
   147	for design information and example programs can help us take full 
   148	advantage of the standard.
   149	
   150	For convenience, data formats should heed the restrictions of various 
   151	processors and environments. E.g. word-alignment greatly helps 68000 
   152	access at insignificant cost to 8088 programs.
   153	
   154	Other goals include the ability to share common elements over a list 
   155	of objects and the ability to construct composite objects containing 
   156	other data objects with structural information like directories.
   157	
   158	And finally, "Simple things should be simple and complex things should 
   159	be possible."	Alan Kay.
   160	
   161	Think Ahead
   162	
   163	Let's think ahead and build programs that read and write files for 
   164	each other and for programs yet to be designed. Build data formats 
   165	to last for future computers so long as the overhead is acceptable. 
   166	This extends the usefulness and life of today's programs and data.
   167	
   168	To maximize interconnectivity, the standard file structure and the 
   169	specific object formats must all be general and extensible. Think 
   170	ahead when designing an object. It should serve many purposes and 
   171	allow many programs to store and read back all the information they 
   172	need; even squeeze in custom data. Then a programmer can store the 
   173	available data and is encouraged to include fixed contextual details. 
   174	Recipient programs can read the needed parts, skip unrecognized stuff, 
   175	default missing data, and use the stored context to help transform 
   176	the data as needed.
   177	
   178	Scope
   179	
   180	IFF addresses these needs by defining a standard file structure, some 
   181	initial data object types, ways to define new types, and rules for 
   182	accessing these files. We can accomplish a great deal by writing programs 
   183	according to this standard, but don't expect direct compatibility 
   184	with existing software. We'll need conversion programs to bridge the 
   185	gap from the old world.
   186	
   187	IFF is geared for computers that readily process information in 8-bit 
   188	bytes. It assumes a "physical layer" of data storage and transmission 
   189	that reliably maintains "files" as strings of 8-bit bytes. The standard 
   190	treats a "file" as a container of data bytes and is independent of 
   191	how to find a file and whether it has a byte count.
   192	
   193	This standard does not by itself implement a clipboard for cutting 
   194	and pasting data between programs. A clipboard needs software to mediate 
   195	access, to maintain a "contents version number" so programs can detect 
   196	updates, and to manage the data in "virtual memory".
   197	
   198	Data Abstraction
   199	
   200	The basic problem is how to represent information  in a way that's 
   201	program-independent, compiler- independent, machine-independent, and 
   202	device-independent.
   203	
   204	The computer science approach is "data abstraction", also known as 
   205	"objects", "actors", and "abstract data types". A data abstraction 
   206	has a "concrete representation" (its storage format), an "abstract 
   207	representation" (its capabilities and uses), and access procedures 
   208	that isolate all the calling software from the concrete representation. 
   209	Only the access procedures touch the data storage. Hiding mutable 
   210	details behind an interface is called "information hiding". What data 
   211	abstraction does is abstract from details of implementing the object, 
   212	namely the selected storage representation and algorithms for manipulating 
   213	it.
   214	
   215	The power of this approach is modularity. By adjusting the access 
   216	procedures we can extend and restructure the data without impacting 
   217	the interface or its callers. Conversely, we can extend and restructure 
   218	the interface and callers without making existing data obsolete. It's 
   219	great for interchange!
   220	
   221	But we seem to need the opposite: fixed file formats for all programs 
   222	to access. Actually, we could file data abstractions ("filed objects") 
   223	by storing the data and access procedures together. We'd have to encode 
   224	the access procedures in a standard machine-independent programming 
   225	language   la PostScript. Even still, the interface can't evolve freely 
   226	since we can't update all copies of the access procedures. So we'll 
   227	have to design our abstract representations for limited evolution 
   228	and occasional revolution (conversion).
   229	
   230	In any case, today's microcomputers can't practically store data abstractions. 
   231	They can do the next best thing: store arbitrary types of data in 
   232	"data chunks", each with a type identifier and a length count. The 
   233	type identifier is a reference by name to the access procedures (any 
   234	local implementation). The length count enables storage-level object 
   235	operations like "copy" and "skip to next" independent of object type.
   236	
   237	Chunk writing is straightforward. Chunk reading requires a trivial 
   238	parser to scan each chunk and dispatch to the proper access/conversion 
   239	procedure. Reading chunks nested inside other chunks requires recursion, 
   240	but no lookahead or backup.
   241	
   242	That's the main idea of IFF. There are, of course, a few other detailsI
   243	
   244	Previous Work
   245	
   246	Where our needs are similar, we borrow from existing standards.
   247	
   248	Our basic need to move data between independently developed programs 
   249	is similar to that addressed by the Apple Macintosh desk scrap or 
   250	"clipboard" [Inside Macintosh chapter "Scrap Manager"]. The Scrap 
   251	Manager works closely with the Resource Manager, a handy filer and 
   252	swapper for data objects (text strings, dialog window templates, pictures, 
   253	fontsI) including types yet to be designed [Inside Macintosh chapter 
   254	"Resource Manager"]. The Resource Manager is a kin to Smalltalk's 
   255	object swapper.
   256	
   257	We will probably write a Macintosh desk accessory that converts IFF 
   258	files to and from the Macintosh clipboard for quick and easy interchange 
   259	with programs like MacPaint and Resource Mover.
   260	
   261	Macintosh uses a simple and elegant scheme of 4-character "identifiers" 
   262	to identify resource types, clipboard format types, file types, and 
   263	file creator programs. Alternatives are unique ID numbers assigned 
   264	by a central authority or by hierarchical authorities, unique ID numbers 
   265	generated by algorithm, other fixed length character strings, and 
   266	variable length strings. Character string identifiers double as readable 
   267	signposts in data files and programs. The choice of 4 characters is 
   268	a good tradeoff between storage space, fetch/compare/store time, and 
   269	name space size. We'll honor Apple's designers by adopting this scheme.
   270	
   271	"PICT" is a good example of a standard structured graphics format 
   272	(including raster images) and its many uses [Inside Macintosh chapter 
   273	"QuickDraw"]. Macintosh provides QuickDraw routines in ROM to create, 
   274	manipulate, and display PICTs. Any application can create a PICT by 
   275	simply asking QuickDraw to record a sequence of drawing commands. 
   276	Since it's just as easy to ask QuickDraw to render a PICT to a screen 
   277	or a printer, it's very effective to pass them between programs, say 
   278	from an illustrator to a word processor. An important feature is the 
   279	ability to store "comments" in a PICT which QuickDraw will ignore. 
   280	Actually, it passes them to your optional custom "comment handler".
   281	
   282	PostScript, Adobe's print file standard, is a more general way to 
   283	represent any print image (which is a specification for putting marks 
   284	on paper) [PostScript Language Manual]. In fact, PostScript is a full-fledged 
   285	programming language. To interpret a PostScript program is to render 
   286	a document on a raster output device. The language is defined in layers: 
   287	a lexical layer of identifiers, constants, and operators; a layer 
   288	of reverse polish semantics including scope rules and a way to define 
   289	new subroutines; and a printing-specific layer of built-in identifiers 
   290	and operators for rendering graphic images. It is clearly a powerful 
   291	(Turing equivalent) image definition language. PICT and a subset of 
   292	PostScript are candidates for structured graphics standards.
   293	
   294	A PostScript document can be printed on any raster output device (including 
   295	a display) but cannot generally be edited. That's because the original 
   296	flexibility and constraints have been discarded. Besides, a PostScript 
   297	program may use arbitrary computation to supply parameters like placement 
   298	and size to each operator. A QuickDraw PICT, in comparison, is a more 
   299	restricted format of graphic primitives parameterized by constants. 
   300	So a PICT can be edited at the level of the primitives, e.g. move 
   301	or thicken a line. It cannot be edited at the higher level of, say, 
   302	the bar chart data which generated the picture.
   303	
   304	PostScript has another limitation: Not all kinds of data amount to 
   305	marks on paper. A musical instrument description is one example. PostScript 
   306	is just not geared for such uses.
   307	
   308	"DIF" is another example of data being stored in a general format 
   309	usable by future programs [DIF Technical Specification]. DIF is a 
   310	format for spreadsheet data interchange. DIF and PostScript are both 
   311	expressed in plain ASCII text files. This is very handy for printing, 
   312	debugging, experimenting, and transmitting across modems. It can have 
   313	substantial cost in compaction and read/write work, depending on use. 
   314	We won't store IFF files this way but we could define an ASCII alternate 
   315	representation with a converter program.
   316	
   317	InterScript is Xerox' standard for interchange of editable documents 
   318	[Introduction to InterScript]. It approaches a harder problem: How 
   319	to represent editable word processor documents that may contain formatted 
   320	text, pictures, cross-references like figure numbers, and even highly 
   321	specialized objects like mathematical equations? InterScript aims 
   322	to define one standard representation for each kind of information. 
   323	Each InterScript-compatible editor is supposed to preserve the objects 
   324	it doesn't understand and even maintain nested cross-references. So 
   325	a simple word processor would let you edit the text of a fancy document 
   326	without discarding the equations or disrupting the equation numbers.
   327	
   328	Our task is similarly to store high level information and preserve 
   329	as much content as practical while moving it between programs. But 
   330	we need to span a larger universe of data types and cannot expect 
   331	to centrally define them all. Fortunately, we don't need to make programs 
   332	preserve information that they don't understand. And for better or 
   333	worse, we don't have to tackle general-purpose cross-references yet.
   334	
   335	
   336	
   337	3. Primitive Data Types
   338	
   339	Atomic components such as integers and characters that are interpretable 
   340	directly by the CPU are specified in one format for all processors. 
   341	We chose a format that's most convenient for the Motorola MC68000 
   342	processor [M68000 16/32-Bit Microprocessor Programmer's Reference 
   343	Manual].
   344	
   345	N.B.: Part 3 dictates the format for "primitive" data types where and 
   346	only where used in the overall file structure and standard kinds of 
   347	chunks (Cf. Chunks). The number of such occurrences will be small 
   348	enough that the costs of conversion, storage, and management of processor-
   349	specific files would far exceed the costs of conversion during I/O by "foreign" 
   350	programs. A particular data chunk may be specified with a different 
   351	format for its internal primitive types or with processor- or environment-
   352	speci fic variants if necessary to optimize local usage. Since that hurts 
   353	data interchange, it's not recommended. (Cf. Designing New Data Sections, 
   354	in Part 4.)
   355	
   356	Alignment
   357	
   358	All data objects larger than a byte are aligned on even byte addresses 
   359	relative to the start of the file. This may require padding. Pad bytes 
   360	are to be written as zeros, but don't count on that when reading.
   361	
   362	This means that every odd-length "chunk" (see below) must be padded 
   363	so that the next one will fall on an even boundary. Also, designers 
   364	of structures to be stored in chunks should include pad fields where 
   365	needed to align every field larger than a byte. Zeros should be stored 
   366	in all the pad bytes.
   367	
   368	Justification: Even-alignment causes a little extra work for files 
   369	that are used only on certain processors but allows 68000 programs 
   370	to construct and scan the data in memory and do block I/O. You just 
   371	add an occasional pad field to data structures that you're going to 
   372	block read/write or else stream read/write an extra byte. And the 
   373	same source code works on all processors. Unspecified alignment, on 
   374	the other hand, would force 68000 programs to (dis)assemble word and 
   375	long-word data one byte at a time. Pretty cumbersome in a high level 
   376	language. And if you don't conditionally compile that out for other 
   377	processors, you won't gain anything.
   378	
   379	Numbers
   380	
   381	Numeric types supported are two's complement binary integers in the 
   382	format used by the MC68000 processor high byte first, high word first the 
   383	reverse of 8088 and 6502 format. They could potentially include signed 
   384	and unsigned 8, 16, and 32 bit integers but the standard only uses 
   385	the following:
   386	
   387	UBYTE	 8 bits unsigned
   388	WORD	16 bits signed
   389	UWORD	16 bits unsigned
   390	LONG	32 bits signed
   391	
   392	The actual type definitions depend on the CPU and the compiler. In 
   393	this document, we'll express data type definitions in the C programming 
   394	language. [See C, A Reference Manual.] In 68000 Lattice C:
   395	
   396	typedef unsigned char	UBYTE;	/*  8 bits unsigned	*/
   397	typedef short	WORD;	/* 16 bits signed	*/
   398	typedef unsigned short	UWORD;	/* 16 bits unsigned	*/
   399	typedef long	LONG;	/* 32 bits signed	*/
   400	
   401	Characters
   402	
   403	The following character set is assumed wherever characters are used, 
   404	e.g. in text strings, IDs, and TEXT chunks (see below).
   405	
   406	Characters are encoded in 8-bit ASCII. Characters in the range NUL 
   407	(hex 0) through DEL (hex 7F) are well defined by the 7-bit ASCII standard. 
   408	IFF uses the graphic group RJS (SP, hex 20) through R~S (hex 7E).
   409	
   410	Most of the control character group hex 01 through hex 1F have no 
   411	standard meaning in IFF. The control character LF (hex 0A) is defined 
   412	as a "newline" character. It denotes an intentional line break, that 
   413	is, a paragraph or line terminator. (There is no way to store an automatic 
   414	line break. That is strictly a function of the margins in the environment 
   415	the text is placed.) The control character ESC (hex 1B) is a reserved 
   416	escape character under the rules of ANSI standard 3.64-1979 American 
   417	National Standard Additional Control Codes for Use with ASCII, ISO 
   418	standard 2022, and ISO/DIS standard 6429.2.
   419	
   420	Characters in the range hex 7F through hex FF are not globally defined 
   421	in IFF. They are best left reserved for future standardization. But 
   422	note that the FORM type FTXT (formatted text) defines the meaning 
   423	of these characters within FTXT forms. In particular, character values 
   424	hex 7F through hex 9F are control codes while characters hex A0 through 
   425	hex FF are extended graphic characters like  , as per the ISO and 
   426	ANSI standards cited above. [See the supplementary document "FTXT" 
   427	IFF Formatted Text.]
   428	
   429	Dates
   430	
   431	A "creation date" is defined as the date and time a stream of data 
   432	bytes was created. (Some systems call this a "last modified date".) 
   433	Editing some data changes its creation date. Moving the data between 
   434	volumes or machines does not.
   435	
   436	The IFF standard date format will be one of those used in MS-DOS, 
   437	Macintosh, or Amiga DOS (probably a 32-bit unsigned number of seconds 
   438	since a reference point). Issue: Investigate these three.
   439	
   440	Type IDs
   441	
   442	A "type ID", "property name", "FORM type", or any other IFF identifier 
   443	is a 32-bit value: the concatenation of four ASCII characters in the 
   444	range R S (SP, hex 20) through R~S (hex 7E). Spaces (hex 20) should 
   445	not precede printing characters; trailing spaces are ok. Control characters 
   446	are forbidden.
   447	
   448	typedef CHAR ID[4];
   449	
   450	IDs are compared using a simple 32-bit case-dependent equality test.
   451	
   452	Data section type IDs (aka FORM types) are restriced IDs. (Cf. Data 
   453	Sections.) Since they may be stored in filename extensions (Cf. Single 
   454	Purpose Files) lower case letters and punctuation marks are forbidden. 
   455	Trailing spaces are ok.
   456	
   457	Carefully choose those four characters when you pick a new ID. Make 
   458	them mnemonic so programmers can look at an interchange format file 
   459	and figure out what kind of data it contains. The name space makes 
   460	it possible for developers scattered around the globe to generate 
   461	ID values with minimal collisions so long as they choose specific 
   462	names like "MUS4" instead of general ones like "TYPE" and "FILE". 
   463	EA will "register" new FORM type IDs and format descriptions as they're 
   464	devised, but collisions will be improbable so there will be no pressure 
   465	on this "clearinghouse" process. Appendix A has a list of currently 
   466	defined IDs.
   467	
   468	Sometimes it's necessary to make data format changes that aren't backward 
   469	compatible. Since IDs are used to denote data formats in IFF, new 
   470	IDs are chosen to denote revised formats. Since programs won't read 
   471	chunks whose IDs they don't recognize (see Chunks, below), the new 
   472	IDs keep old programs from stumbling over new data. The conventional 
   473	way to chose a "revision" ID is to increment the last character if 
   474	it's a digit or else change the last character to a digit. E.g. first 
   475	and second revisions of the ID "XY" would be "XY1" and "XY2". Revisions 
   476	of "CMAP" would be "CMA1" and "CMA2".
   477	
   478	Chunks
   479	
   480	Chunks are the building blocks in the IFF structure. The form expressed 
   481	as a C typedef is:
   482	
   483	typedef struct {
   484		ID	ckID;
   485		LONG	ckSize;	/* sizeof(ckData) */
   486		UBYTE	ckData[/* ckSize */];
   487		} Chunk;
   488	
   489	We can diagram an example chunk a "CMAP" chunk containing 12 data 
   490	bytes like this:
   491				----------------
   492			ckID:	|    'CMAP'    |
   493			ckSize: |      12      |
   494			ckData: | 0, 0, 0, 32  |   -------- 
   495				| 0, 0, 64, 0  |    12 bytes
   496				| 0, 0, 64, 0  |   ---------
   497				----------------
   498	
   499	The fixed header part means "Here's a type ckID chunk with ckSize 
   500	bytes of data."
   501	
   502	The ckID identifies the format and purpose of the chunk. As a rule, 
   503	a program must recognize ckID to interpret ckData. It should skip 
   504	over all unrecognized chunks. The ckID also serves as a format version 
   505	number as long as we pick new IDs to identify new formats of ckData 
   506	(see above).
   507	
   508	The following ckIDs are universally reserved to identify chunks with 
   509	particular IFF meanings: "LIST", "FORM", "PROP", "CAT ", and "    
   510	". The special ID "    " (4 spaces) is a ckID for "filler" chunks, 
   511	that is, chunks that fill space but have no meaningful contents. The 
   512	IDs "LIS1" through "LIS9", "FOR1" through "FOR9", and "CAT1" through 
   513	"CAT9" are reserved for future "version number" variations. All IFF-compatible 
   514	software must account for these 23 chunk IDs. Appendix A has a list 
   515	of predefined IDs.
   516	
   517	The ckSize is a logical block size how many data bytes are in ckData. 
   518	If ckData is an odd number of bytes long, a 0 pad byte follows which 
   519	is not included in ckSize. (Cf. Alignment.) A chunk's total physical 
   520	size is ckSize rounded up to an even number plus the size of the header. 
   521	So the smallest chunk is 8 bytes long with ckSize = 0. For the sake 
   522	of following chunks, programs must respect every chunk's ckSize as 
   523	a virtual end-of-file for reading its ckData even if that data is 
   524	malformed, e.g. if nested contents are truncated.
   525	
   526	We can describe the syntax of a chunk as a regular expression with 
   527	"#" representing the ckSize, i.e. the length of the following {braced} 
   528	bytes. The "[0]" represents a sometimes needed pad byte. (The regular 
   529	expressions in this document are collected in Appendix A along with 
   530	an explanation of notation.)
   531	
   532	Chunk	::= ID #{ UBYTE* } [0]
   533	
   534	One chunk output technique is to stream write a chunk header, stream 
   535	write the chunk contents, then random access back to the header to 
   536	fill in the size. Another technique is to make a preliminary pass 
   537	over the data to compute the size, then write it out all at once.
   538	
   539	Strings, String Chunks, and String Properties
   540	
   541	In a string of ASCII text, LF denotes a forced line break (paragraph 
   542	or line terminator). Other control characters are not used. (Cf. Characters.)
   543	
   544	The ckID for a chunk that contains a string of plain, unformatted 
   545	text is "TEXT". As a practical matter, a text string should probably 
   546	not be longer than 32767 bytes. The standard allows up to 231 - 1 
   547	bytes.
   548	
   549	When used as a data property (see below), a text string chunk may 
   550	be 0 to 255 characters long. Such a string is readily converted to 
   551	a C string or a Pascal STRING[255]. The ckID of a property must be 
   552	the property name, not "TEXT".
   553	
   554	When used as a part of a chunk or data property, restricted C string 
   555	format is normally used. That means 0 to 255 characters followed by 
   556	a NUL byte (ASCII value 0).
   557	
   558	Data Properties
   559	
   560	Data properties specify attributes for following (non-property) chunks. 
   561	A data property essentially says "identifier = value", for example 
   562	"XY = (10, 200)", telling something about following chunks. Properties 
   563	may only appear inside data sections ("FORM" chunks, cf. Data Sections) 
   564	and property sections ("PROP" chunks, cf. Group PROP).
   565	
   566	The form of a data property is a special case of Chunk. The ckID is 
   567	a property name as well as a property type. The ckSize should be small 
   568	since data properties are intended to be accumulated in RAM when reading 
   569	a file. (256 bytes is a reasonable upper bound.) Syntactically:
   570	
   571	Property	::= Chunk
   572	
   573	When designing a data object, use properties to describe context information 
   574	like the size of an image, even if they don't vary in your program. 
   575	Other programs will need this information.
   576	
   577	Think of property settings as assignments to variables in a programming 
   578	language. Multiple assignments are redundant and local assignments 
   579	temporarily override global assignments. The order of assignments 
   580	doesn't matter as long as they precede the affected chunks. (Cf. LISTs, 
   581	CATs, and Shared Properties.)
   582	
   583	Each object type (FORM type) is a local name space for property IDs. 
   584	Think of a "CMAP" property in a "FORM ILBM" as the qualified ID "ILBM.CMAP". 
   585	Property IDs specified when an object type is designed (and therefore 
   586	known to all clients) are called "standard" while specialized ones 
   587	added later are "nonstandard".
   588	
   589	Links
   590	
   591	Issue: A standard mechanism for "links" or "cross references" is very 
   592	desirable for things like combining images and sounds into animations. 
   593	Perhaps we'll define "link" chunks within FORMs that refer to other 
   594	FORMs or to specific chunks within the same and other FORMs. This 
   595	needs further work. EA IFF 1985 has no standard link mechanism.
   596	
   597	For now, it may suffice to read a list of, say, musical instruments, 
   598	and then just refer to them within a musical score by index number.
   599	
   600	File References
   601	
   602	Issue: We may need a standard form for references to other files. 
   603	A "file ref" could name a directory and a file in the same type of 
   604	operating system as the ref's originator. Following the reference 
   605	would expect the file to be on some mounted volume. In a network environment, 
   606	a file ref could name a server, too.
   607	
   608	Issue: How can we express operating-system independent file refs?
   609	
   610	Issue: What about a means to reference a portion of another file? 
   611	Would this be a "file ref" plus a reference to a "link" within the 
   612	target file?
   613	
   614	
   615	
   616	4. Data Sections
   617	
   618	The first thing we need of a file is to check: Does it contain IFF 
   619	data and, if so, does it contain the kind of data we're looking for? 
   620	So we come to the notion of a "data section".
   621	
   622	A "data section" or IFF "FORM" is one self-contained "data object" 
   623	that might be stored in a file by itself. It is one high level data 
   624	object such as a picture or a sound effect. The IFF structure "FORM" 
   625	makes it self- identifying. It could be a composite object like a 
   626	musical score with nested musical instrument descriptions.
   627	
   628	Group FORM
   629	
   630	A data section is a chunk with ckID "FORM" and this arrangement:
   631	
   632	FORM	::= "FORM" #{ FormType (LocalChunk | FORM | LIST | CAT)* 
   633	}
   634	FormType	::= ID
   635	LocalChunk	::= Property | Chunk
   636	
   637	The ID "FORM" is a syntactic keyword like "struct" in C. Think of 
   638	a "struct ILBM" containing a field "CMAP". If you see "FORM" you'll 
   639	know to expect a FORM type ID (the structure name, "ILBM" in this 
   640	example) and a particular contents arrangement or "syntax" (local 
   641	chunks, FORMs, LISTs, and CATs). (LISTs and CATs are discussed in 
   642	part 5, below.) A "FORM ILBM", in particular, might contain a local 
   643	chunk "CMAP", an "ILBM.CMAP" (to use a qualified name).
   644	
   645	So the chunk ID "FORM" indicates a data section. It implies that the 
   646	chunk contains an ID and some number of nested chunks. In reading 
   647	a FORM, like any other chunk, programs must respect its ckSize as 
   648	a virtual end-of-file for reading its contents, even if they're truncated.
   649	
   650	The FormType (or FORM type) is a restricted ID that may not contain 
   651	lower case letters or punctuation characters. (Cf. Type IDs. Cf. Single 
   652	Purpose Files.)
   653	
   654	The type-specific information in a FORM is composed of its "local 
   655	chunks": data properties and other chunks. Each FORM type is a local 
   656	name space for local chunk IDs. So "CMAP" local chunks in other FORM 
   657	types may be unrelated to "ILBM.CMAP". More than that, each FORM type 
   658	defines semantic scope. If you know what a FORM ILBM is, you'll know 
   659	what an ILBM.CMAP is.
   660	
   661	Local chunks defined when the FORM type is designed (and therefore 
   662	known to all clients of this type) are called "standard" while specialized 
   663	ones added later are "nonstandard".
   664	
   665	Among the local chunks, property chunks give settings for various 
   666	details like text font while the other chunks supply the essential 
   667	information. This distinction is not clear cut. A property setting 
   668	cancelled by a later setting of the same property has effect only 
   669	on data chunks in between. E.g. in the sequence:
   670	
   671	prop1 = x  (propN = value)*  prop1 = y
   672	
   673	where the propNs are not prop1, the setting prop1 = x has no effect.
   674	
   675	The following universal chunk IDs are reserved inside any FORM: "LIST", 
   676	"FORM", "PROP", "CAT ", "JJJJ", "LIS1" through "LIS9", "FOR1" through 
   677	"FOR9", and "CAT1" through "CAT9". (Cf. Chunks. Cf. Group LIST. Cf. 
   678	Group PROP.) For clarity, these universal chunk names may not be FORM 
   679	type IDs, either.
   680	
   681	Part 5, below, talks about grouping FORMs into LISTs and CATs. They 
   682	let you group a bunch of FORMs but don't impose any particular meaning 
   683	or constraints on the grouping. Read on.
   684	
   685	Composite FORMs
   686	
   687	A FORM chunk inside a FORM is a full-fledged data section. This means 
   688	you can build a composite object like a multi-frame animation sequence 
   689	from available picture FORMs and sound effect FORMs. You can insert 
   690	additional chunks with information like frame rate and frame count.
   691	
   692	Using composite FORMs, you leverage on existing programs that create 
   693	and edit the component FORMs. Those editors may even look into your 
   694	composite object to copy out its type of component, although it'll 
   695	be the rare program that's fancy enough to do that. Such editors are 
   696	not allowed to replace their component objects within your composite 
   697	object. That's because the IFF standard lets you specify consistency 
   698	requirements for the composite FORM such as maintaining a count or 
   699	a directory of the components. Only programs that are written to uphold 
   700	the rules of your FORM type should create or modify such FORMs.
   701	
   702	Therefore, in designing a program that creates composite objects, 
   703	you are strongly requested to provide a facility for your users to 
   704	import and export the nested FORMs. Import and export could move the 
   705	data through a clipboard or a file.
   706	
   707	Here are several existing FORM types and rules for defining new ones.
   708	
   709	FTXT
   710	
   711	An FTXT data section contains text with character formatting information 
   712	like fonts and faces. It has no paragraph or document formatting information 
   713	like margins and page headers. FORM FTXT is well matched to the text 
   714	representation in Amiga's Intuition environment. See the supplemental 
   715	document "FTXT" IFF Formatted Text.
   716	
   717	ILBM
   718	
   719	"ILBM" is an InterLeaved BitMap image with color map; a machine-independent 
   720	format for raster images. FORM ILBM is the standard image file format 
   721	for the Commodore-Amiga computer and is useful in other environments, 
   722	too. See the supplemental document "ILBM" IFF Interleaved Bitmap.
   723	
   724	PICS
   725	
   726	The data chunk inside a "PICS" data section has ID "PICT" and holds 
   727	a QuickDraw picture. Issue: Allow more than one PICT in a PICS? See 
   728	Inside Macintosh chapter "QuickDraw" for details on PICTs and how 
   729	to create and display them on the Macintosh computer.
   730	
   731	The only standard property for PICS is "XY", an optional property 
   732	that indicates the position of the PICT relative to "the big picture". 
   733	The contents of an XY is a QuickDraw Point.
   734	
   735	Note: PICT may be limited to Macintosh use, in which case there'll 
   736	be another format for structured graphics in other environments.
   737	
   738	Other Macintosh Resource Types
   739	
   740	Some other Macintosh resource types could be adopted for use within 
   741	IFF files; perhaps MWRT, ICN, ICN#, and STR#.
   742	
   743	Issue: Consider the candidates and reserve some more IDs.
   744	
   745	Designing New Data Sections
   746	
   747	Supplemental documents will define additional object types. A supplement 
   748	needs to specify the object's purpose, its FORM type ID, the IDs and 
   749	formats of standard local chunks, and rules for generating and interpreting 
   750	the data. It's a good idea to supply typedefs and an example source 
   751	program that accesses the new object. See "ILBM" IFF Interleaved Bitmap 
   752	for a good example.
   753	
   754	Anyone can pick a new FORM type ID but should reserve it with Electronic 
   755	Arts at their earliest convenience. [Issue: EA contact person? Hand 
   756	this off to another organization?] While decentralized format definitions 
   757	and extensions are possible in IFF, our preference is to get design 
   758	consensus by committee, implement a program to read and write it, 
   759	perhaps tune the format, and then publish the format with example 
   760	code. Some organization should remain in charge of answering questions 
   761	and coordinating extensions to the format.
   762	
   763	If it becomes necessary to revise the design of some data section, 
   764	its FORM type ID will serve as a version number (Cf. Type IDs). E.g. 
   765	a revised "VDEO" data section could be called "VDE1". But try to get 
   766	by with compatible revisions within the existing FORM type.
   767	
   768	In a new FORM type, the rules for primitive data types and word-alignment 
   769	(Cf. Primitive Data Types) may be overriden for the contents of its 
   770	local chunks but not for the chunk structure itself if your documentation 
   771	spells out the deviations. If machine-specific type variants are needed, 
   772	e.g. to store vast numbers of integers in reverse bit order, then 
   773	outline the conversion algorithm and indicate the variant inside each 
   774	file, perhaps via different FORM types. Needless to say, variations 
   775	should be minimized.
   776	
   777	In designing a FORM type, encapsulate all the data that other programs 
   778	will need to interpret your files. E.g. a raster graphics image should 
   779	specify the image size even if your program always uses 320 x 200 
   780	pixels x 3 bitplanes. Receiving programs are then empowered to append 
   781	or clip the image rectangle, to add or drop bitplanes, etc. This enables 
   782	a lot more compatibility.
   783	
   784	Separate the central data (like musical notes) from more specialized 
   785	information (like note beams) so simpler programs can extract the 
   786	central parts during read-in. Leave room for expansion so other programs 
   787	can squeeze in new kinds of information (like lyrics). And remember 
   788	to keep the property chunks manageably short let's say 2 256 bytes.
   789	
   790	When designing a data object, try to strike a good tradeoff between 
   791	a super-general format and a highly-specialized one. Fit the details 
   792	to at least one particular need, for example a raster image might 
   793	as well store pixels in the current machine's scan order. But add 
   794	the kind of generality that makes it usable with foreseeable hardware 
   795	and software. E.g. use a whole byte for each red, green, and blue 
   796	color value even if this year's computer has only 4-bit video DACs. 
   797	Think ahead and help other programs so long as the overhead is acceptable. 
   798	E.g. run compress a raster by scan line rather than as a unit so future 
   799	programs can swap images by scan line to and from secondary storage.
   800	
   801	Try to design a general purpose "least common multiple" format that 
   802	encompasses the needs of many programs without getting too complicated. 
   803	Let's coalesce our uses around a few such formats widely separated 
   804	in the vast design space. Two factors make this flexibility and simplicity 
   805	practical. First, file storage space is getting very plentiful, so 
   806	compaction is not a priority. Second, nearly any locally-performed 
   807	data conversion work during file reading and writing will be cheap 
   808	compared to the I/O time.
   809	
   810	It must be ok to copy a LIST or FORM or CAT intact, e.g. to incorporate 
   811	it into a composite FORM. So any kind of internal references within 
   812	a FORM must be relative references. They could be relative to the 
   813	start of the containing FORM, relative from the referencing chunk, 
   814	or a sequence number into a collection.
   815	
   816	With composite FORMs, you leverage on existing programs that create 
   817	and edit the components. If you write a program that creates composite 
   818	objects, please provide a facility for your users to import and export 
   819	the nested FORMs. The import and export functions may move data through 
   820	a separate file or a clipboard.
   821	
   822	Finally, don't forget to specify all implied rules in detail.
   823	
   824	
   825	
   826	5. LISTs, CATs, and Shared Properties
   827	
   828	Data often needs to be grouped together like a list of icons. Sometimes 
   829	a trick like arranging little images into a big raster works, but 
   830	generally they'll need to be structured as a first class group. The 
   831	objects "LIST" and "CAT" are IFF-universal mechanisms for this purpose.
   832	
   833	Property settings sometimes need to be shared over a list of similar 
   834	objects. E.g. a list of icons may share one color map. LIST provides 
   835	a means called "PROP" to do this. One purpose of a LIST is to define 
   836	the scope of a PROP. A "CAT", on the other hand, is simply a concatenation 
   837	of objects.
   838	
   839	Simpler programs may skip LISTs and PROPs altogether and just handle 
   840	FORMs and CATs. All "fully-conforming" IFF programs also know about 
   841	"CAT ", "LIST", and "PROP". Any program that reads a FORM inside a 
   842	LIST must process shared PROPs to correctly interpret that FORM.
   843	
   844	Group CAT
   845	
   846	A CAT is just an untyped group of data objects.
   847	
   848	Structurally, a CAT is a chunk with chunk ID "CAT " containing a "contents 
   849	type" ID followed by the nested objects. The ckSize of each contained 
   850	chunk is essentially a relative pointer to the next one.
   851	
   852	CAT	::= "CAT " #{ ContentsType (FORM | LIST | CAT)* }
   853	ContentsType	::= ID	-- a hint or an "abstract data type" ID
   854	
   855	In reading a CAT, like any other chunk, programs must respect it's 
   856	ckSize as a virtual end-of-file for reading the nested objects even 
   857	if they're malformed or truncated.
   858	
   859	The "contents type" following the CAT's ckSize indicates what kind 
   860	of FORMs are inside. So a CAT of ILBMs would store "ILBM" there. It's 
   861	just a hint. It may be used to store an "abstract data type". A CAT 
   862	could just have blank contents ID ("JJJJ") if it contains more than 
   863	one kind of FORM.
   864	
   865	CAT defines only the format of the group. The group's meaning is open 
   866	to interpretation. This is like a list in LISP: the structure of cells 
   867	is predefined but the meaning of the contents as, say, an association 
   868	list depends on use. If you need a group with an enforced meaning 
   869	(an "abstract data type" or Smalltalk "subclass"), some consistency 
   870	constraints, or additional data chunks, use a composite FORM instead 
   871	(Cf. Composite FORMs).
   872	
   873	Since a CAT just means a concatenation of objects, CATs are rarely 
   874	nested. Programs should really merge CATs rather than nest them.
   875	
   876	Group LIST
   877	
   878	A LIST defines a group very much like CAT but it also gives a scope 
   879	for PROPs (see below). And unlike CATs, LISTs should not be merged 
   880	without understanding their contents.
   881	
   882	Structurally, a LIST is a chunk with ckID "LIST" containing a "contents 
   883	type" ID, optional shared properties, and the nested contents (FORMs, 
   884	LISTs, and CATs), in that order. The ckSize of each contained chunk 
   885	is a relative pointer to the next one. A LIST is not an arbitrary 
   886	linked list the cells are simply concatenated.
   887	
   888	LIST	::= "LIST" #{ ContentsType PROP* (FORM | LIST | CAT)* }
   889	ContentsType	::= ID
   890	
   891	Group PROP
   892	
   893	PROP chunks may appear in LISTs (not in FORMs or CATs). They supply 
   894	shared properties for the FORMs in that LIST. This ability to elevate 
   895	some property settings to shared status for a list of forms is useful 
   896	for both indirection and compaction. E.g. a list of images with the 
   897	same size and colors can share one "size" property and one "color 
   898	map" property. Individual FORMs can override the shared settings.
   899	
   900	The contents of a PROP is like a FORM with no data chunks:
   901	
   902	PROP	::= "PROP" #{ FormType Property* }
   903	
   904	It means, "Here are the shared properties for FORM type <<FormType>."
   905	
   906	A LIST may have at most one PROP of a FORM type, and all the PROPs 
   907	must appear before any of the FORMs or nested LISTs and CATs. You 
   908	can have subsequences of FORMs sharing properties by making each subsequence 
   909	a LIST.
   910	
   911	Scoping: Think of property settings as variable bindings in nested 
   912	blocks of a programming language. Where in C you could write:
   913	
   914	TEXT_FONT text_font = Courier;	/* program's global default	*/
   915	
   916	File(); {
   917		TEXT_FONT text_font = TimesRoman;	/* shared setting	*/
   918	
   919			{
   920			TEXT_FONT text_font = Helvetica;  /* local setting	*/
   921			Print("Hello ");	/* uses font Helvetica	*/
   922			}
   923	
   924			{
   925			Print("there.");	/* uses font TimesRoman	*/
   926			}
   927		}
   928	
   929	An IFF file could contain:
   930	
   931	LIST {
   932		PROP TEXT {
   933			FONT {TimesRoman}	/* shared setting	*/
   934			}
   935	
   936		FORM TEXT {
   937			FONT {Helvetica}	/* local setting	*/
   938			CHRS {Hello }		/* uses font Helvetica	*/
   939			}
   940	
   941		FORM TEXT {
   942			CHRS {there.}	/* uses font TimesRoman	*/
   943			}
   944		}
   945	
   946	The shared property assignments selectively override the reader's 
   947	global defaults, but only for FORMs within the group. A FORM's own 
   948	property assignments selectively override the global and group-supplied 
   949	values. So when reading an IFF file, keep property settings on a stack. 
   950	They're designed to be small enough to hold in main memory.
   951	
   952	Shared properties are semantically equivalent to copying those properties 
   953	into each of the nested FORMs right after their FORM type IDs.
   954	
   955	Properties for LIST
   956	
   957	Optional "properties for LIST" store the origin of the list's contents 
   958	in a PROP chunk for the fake FORM type "LIST". They are the properties 
   959	originating program "OPGM", processor family "OCPU", computer type 
   960	"OCMP", computer serial number or network address "OSN ", and user 
   961	name "UNAM". In our imperfect world, these could be called upon to 
   962	distinguish between unintended variations of a data format or to work 
   963	around bugs in particular originating/receiving program pairs. Issue: 
   964	Specify the format of these properties.
   965	
   966	A creation date could also be stored in a property but let's ask that 
   967	file creating, editing, and transporting programs maintain the correct 
   968	date in the local file system. Programs that move files between machine 
   969	types are expected to copy across the creation dates.
   970	
   971	
   972	
   973	6. Standard File Structure
   974	
   975	File Structure Overview
   976	
   977	An IFF file is just a single chunk of type FORM, LIST, or CAT. Therefore 
   978	an IFF file can be recognized by its first 4 bytes: "FORM", "LIST", 
   979	or "CAT ". Any file contents after the chunk's end are to be ignored.
   980	
   981	Since an IFF file can be a group of objects, programs that read/write 
   982	single objects can communicate to an extent with programs that read/write 
   983	groups. You're encouraged to write programs that handle all the objects 
   984	in a LIST or CAT. A graphics editor, for example, could process a 
   985	list of pictures as a multiple page document, one page at a time.
   986	
   987	Programs should enforce IFF's syntactic rules when reading and writing 
   988	files. This ensures robust data transfer. The public domain IFF reader/writer 
   989	subroutine package does this for you. A utility program "IFFCheck" 
   990	is available that scans an IFF file and checks it for conformance 
   991	to IFF's syntactic rules. IFFCheck also prints an outline of the chunks 
   992	in the file, showing the ckID and ckSize of each. This is quite handy 
   993	when building IFF programs. Example programs are also available to 
   994	show details of reading and writing IFF files.
   995	
   996	A merge program "IFFJoin" will be available that logically appends 
   997	IFF files into a single CAT group. It "unwraps" each input file that 
   998	is a CAT so that the combined file isn't nested CATs.
   999	
  1000	If we need to revise the IFF standard, the three anchoring IDs will 
  1001	be used as "version numbers". That's why IDs "FOR1" through "FOR9", 
  1002	"LIS1" through "LIS9", and "CAT1" through "CAT9" are reserved.
  1003	
  1004	IFF formats are designed for reasonable performance with floppy disks. 
  1005	We achieve considerable simplicity in the formats and programs by 
  1006	relying on the host file system rather than defining universal grouping 
  1007	structures like directories for LIST contents. On huge storage systems, 
  1008	IFF files could be leaf nodes in a file structure like a B-tree. Let's 
  1009	hope the host file system implements that for us!
  1010	
  1011	Thre are two kinds of IFF files: single purpose files and scrap files. 
  1012	They differ in the interpretation of multiple data objects and in 
  1013	the file's external type.
  1014	
  1015	Single Purpose Files
  1016	
  1017	A single purpose IFF file is for normal "document" and "archive" storage. 
  1018	This is in contrast with "scrap files" (see below) and temporary backing 
  1019	storage (non-interchange files).
  1020	
  1021	The external file type (or filename extension, depending on the host 
  1022	file system) indicates the file's contents. It's generally the FORM 
  1023	type of the data contained, hence the restrictions on FORM type IDs.
  1024	
  1025	Programmers and users may pick an "intended use" type as the filename 
  1026	extension to make it easy to filter for the relevant files in a filename 
  1027	requestor. This is actually a "subclass" or "subtype" that conveniently 
  1028	separates files of the same FORM type that have different uses. Programs 
  1029	cannot demand conformity to its expected subtypes without overly restricting 
  1030	data interchange since they cannot know about the subtypes to be used 
  1031	by future programs that users will want to exchange data with.
  1032	
  1033	Issue: How to generate 3-letter MS-DOS extensions from 4-letter FORM 
  1034	type IDs?
  1035	
  1036	Most single purpose files will be a single FORM (perhaps a composite 
  1037	FORM like a musical score containing nested FORMs like musical instrument 
  1038	descriptions). If it's a LIST or a CAT, programs should skip over 
  1039	unrecognized objects to read the recognized ones or the first recognized 
  1040	one. Then a program that can read a single purpose file can read something 
  1041	out of a "scrap file", too.
  1042	
  1043	Scrap Files
  1044	
  1045	A "scrap file" is for maximum interconnectivity in getting data between 
  1046	programs; the core of a clipboard function. Scrap files may have type 
  1047	"IFF " or filename extension ".IFF".
  1048	
  1049	A scrap file is typically a CAT containing alternate representations 
  1050	of the same basic information. Include as many alternatives as you 
  1051	can readily generate. This redundancy improves interconnectivity in 
  1052	situations where we can't make all programs read and write super-general 
  1053	formats. [Inside Macintosh chapter "Scrap Manager".] E.g. a graphically-
  1054	annotated musical score might be supplemented by a stripped down 4-voice 
  1055	melody and by a text (the lyrics).
  1056	
  1057	The originating program should write the alternate representations 
  1058	in order of "preference": most preferred (most comprehensive) type 
  1059	to least preferred (least comprehensive) type. A receiving program 
  1060	should either use the first appearing type that it understands or 
  1061	search for its own "preferred" type.
  1062	
  1063	A scrap file should have at most one alternative of any type. (A LIST 
  1064	of same type objects is ok as one of the alternatives.) But don't 
  1065	count on this when reading; ignore extra sections of a type. Then 
  1066	a program that reads scrap files can read something out of single 
  1067	purpose files.
  1068	
  1069	Rules for Reader Programs
  1070	
  1071	Here are some notes on building programs that read IFF files. If you 
  1072	use the standard IFF reader module "IFFR.C", many of these rules and 
  1073	details will be automatically handled. (See "Support Software" in 
  1074	Appendix A.) We recommend that you start from the example program 
  1075	"ShowILBM.C". You should also read up on recursive descent parsers. 
  1076	[See, for example, Compiler Construction, An Advanced Course.]
  1077	
  1078	%	The standard is very flexible so many programs can exchange 
  1079	data. This implies a program has to scan the file and react to what's 
  1080	actually there in whatever order it appears. An IFF reader program 
  1081	is a parser.
  1082	
  1083	%	For interchange to really work, programs must be willing to 
  1084	do some conversion during read-in. If the data isn't exactly what 
  1085	you expect, say, the raster is smaller than those created by your 
  1086	program, then adjust it. Similarly, your program could crop a large 
  1087	picture, add or drop bitplanes, and create/discard a mask plane. The 
  1088	program should give up gracefully on data that it can't convert.
  1089	
  1090	%	If it doesn't start with "FORM", "LIST", or "CAT ", it's not 
  1091	an IFF-85 file.
  1092	
  1093	%	For any chunk you encounter, you must recognize its type ID 
  1094	to understand its contents.
  1095	
  1096	%	For any FORM chunk you encounter, you must recognize its FORM 
  1097	type ID to understand the contained "local chunks". Even if you don't 
  1098	recognize the FORM type, you can still scan it for nested FORMs, LISTs, 
  1099	and CATs of interest.
  1100	
  1101	%	Don't forget to skip the pad byte after every odd-length chunk.
  1102	
  1103	%	Chunk types LIST, FORM, PROP, and CAT are generic groups. They 
  1104	always contain a subtype ID followed by chunks.
  1105	
  1106	%	Readers ought to handle a CAT of FORMs in a file. You may treat 
  1107	the FORMs like document pages to sequence through or just use the 
  1108	first FORM.
  1109	
  1110	%	Simpler IFF readers completely skip LISTs. "Fully IFF-conforming" 
  1111	readers are those that handle LISTs, even if just to read the first 
  1112	FORM from a file. If you do look into a LIST, you must process shared 
  1113	properties (in PROP chunks) properly. The idea is to get the correct 
  1114	data or none at all.
  1115	
  1116	%	The nicest readers are willing to look into unrecognized FORMs 
  1117	for nested FORM types that they do recognize. For example, a musical 
  1118	score may contain nested instrument descriptions and an animation 
  1119	file may contain still pictures.
  1120	
  1121	Note to programmers: Processing PROP chunks is not simple! You'll 
  1122	need some background in interpreters with stack frames. If this is 
  1123	foreign to you, build programs that read/write only one FORM per file. 
  1124	For the more intrepid programmers, the next paragraph summarizes how 
  1125	to process LISTs and PROPs. See the general IFF reader module "IFFR.C" 
  1126	and the example program "ShowILBM.C" for details.
  1127	
  1128	Allocate a stack frame for every LIST and FORM you encounter and initialize 
  1129	it by copying the stack frame of the parent LIST or FORM. At the top 
  1130	level, you'll need a stack frame initialized to your program's global 
  1131	defaults. While reading each LIST or FORM, store all encountered properties 
  1132	into the current stack frame. In the example ShowILBM, each stack 
  1133	frame has a place for a bitmap header property ILBM.BMHD and a color 
  1134	map property ILBM.CMAP. When you finally get to the ILBM's BODY chunk, 
  1135	use the property settings accumulated in the current stack frame.
  1136	
  1137	An alternate implementation would just remember PROPs encountered, 
  1138	forgetting each on reaching the end of its scope (the end of the containing 
  1139	LIST). When a FORM XXXX is encountered, scan the chunks in all remembered 
  1140	PROPs XXXX, in order, as if they appeared before the chunks actually 
  1141	in the FORM XXXX. This gets trickier if you read FORMs inside of FORMs.
  1142	
  1143	Rules for Writer Programs
  1144	
  1145	Here are some notes on building programs that write IFF files, which 
  1146	is much easier than reading them. If you use the standard IFF writer 
  1147	module "IFFW.C" (see "Support Software" in Appendix A), many of these 
  1148	rules and details will automatically be enforced. See the example 
  1149	program "Raw2ILBM.C".
  1150	
  1151	%	An IFF file is a single FORM, LIST, or CAT chunk.
  1152	
  1153	%	Any IFF-85 file must start with the 4 characters "FORM", "LIST", 
  1154	or "CAT ", followed by a LONG ckSize. There should be no data after 
  1155	the chunk end.
  1156	
  1157	%	Chunk types LIST, FORM, PROP, and CAT are generic. They always 
  1158	contain a subtype ID followed by chunks. These three IDs are universally 
  1159	reserved, as are "LIS1" through "LIS9", "FOR1" through "FOR9", "CAT1" 
  1160	through "CAT9", and "    ".
  1161	
  1162	%	Don't forget to write a 0 pad byte after each odd-length chunk.
  1163	
  1164	%	Four techniques for writing an IFF group: (1) build the data 
  1165	in a file mapped into virtual memory, (2) build the data in memory 
  1166	blocks and use block I/O, (3) stream write the data piecemeal and 
  1167	(don't forget!) random access back to set the group length count, 
  1168	and (4) make a preliminary pass to compute the length count then stream 
  1169	write the data.
  1170	
  1171	%	Do not try to edit a file that you don't know how to create. 
  1172	Programs may look into a file and copy out nested FORMs of types that 
  1173	they recognize, but don't edit and replace the nested FORMs and don't 
  1174	add or remove them. That could make the containing structure inconsistent. 
  1175	You may write a new file containing items you copied (or copied and 
  1176	modified) from another IFF file, but don't copy structural parts you 
  1177	don't understand.
  1178	
  1179	%	You must adhere to the syntax descriptions in Appendex A. E.g. 
  1180	PROPs may only appear inside LISTs.
  1181	
  1182	
  1183	
  1184	
  1185	Appendix A. Reference
  1186	
  1187	Type Definitions
  1188	
  1189	The following C typedefs describe standard IFF structures. Declarations 
  1190	to use in practice will vary with the CPU and compiler. For example, 
  1191	68000 Lattice C produces efficient comparison code if we define ID 
  1192	as a "LONG". A macro "MakeID" builds these IDs at compile time.
  1193	
  1194	/* Standard IFF types, expressed in 68000 Lattice C.	*/
  1195	
  1196	typedef unsigned char UBYTE;	/*  8 bits unsigned	*/
  1197	typedef short WORD;	/* 16 bits signed	*/
  1198	typedef unsigned short UWORD;	/* 16 bits unsigned	*/
  1199	typedef long LONG;	/* 32 bits signed	*/
  1200	
  1201	typedef char ID[4];	/* 4 chars in ' ' through '~'	*/
  1202	
  1203	typedef struct {
  1204		ID	ckID;
  1205		LONG	ckSize;	/* sizeof(ckData)	*/
  1206		UBYTE	ckData[/* ckSize */];
  1207		} Chunk;
  1208	
  1209	/* ID typedef and builder for 68000 Lattice C. */
  1210	typedef LONG ID; 	/* 4 chars in ' ' through '~'	*/
  1211	#define MakeID(a,b,c,d) ( (a)<<<<24 | (b)<<<<16 | (c)<<<<8 | (d) )
  1212	
  1213	/* Globally reserved IDs. */
  1214	#define ID_FORM   MakeID('F','O','R','M')
  1215	#define ID_LIST   MakeID('L','I','S','T')
  1216	#define ID_PROP   MakeID('P','R','O','P')
  1217	#define ID_CAT    MakeID('C','A','T',' ')
  1218	#define ID_FILLER MakeID(' ',' ',' ',' ')
  1219	
  1220	Syntax Definitions
  1221	
  1222	Here's a collection of the syntax definitions in this document.
  1223	
  1224	Chunk	::= ID #{ UBYTE* } [0]
  1225	
  1226	Property	::= Chunk
  1227	
  1228	FORM	::= "FORM" #{ FormType (LocalChunk | FORM | LIST | CAT)* 
  1229	}
  1230	FormType	::= ID
  1231	LocalChunk	::= Property | Chunk
  1232	
  1233	CAT	::= "CAT " #{ ContentsType (FORM | LIST | CAT)* }
  1234	ContentsType	::= ID	-- a hint or an "abstract data type" ID
  1235	
  1236	LIST	::= "LIST" #{ ContentsType PROP* (FORM | LIST | CAT)* }
  1237	PROP	::= "PROP" #{ FormType Property* }
  1238	
  1239	In this extended regular expression notation, the token "#" represents 
  1240	a ckSize LONG count of the following {braced} data bytes. Literal 
  1241	items are shown in "quotes", [square bracketed items] are optional, 
  1242	and "*" means 0 or more instances. A sometimes-needed pad byte is 
  1243	shown as "[0]".
  1244	
  1245	Defined Chunk IDs
  1246	
  1247	This is a table of currently defined chunk IDs. We may also borrow 
  1248	some Macintosh IDs and data formats.
  1249	
  1250	Group chunk IDs
  1251		FORM, LIST, PROP, CAT.
  1252	Future revision group chunk IDs
  1253		FOR1 I FOR9, LIS1 I LIS9, CAT1 I CAT9.
  1254	FORM type IDs
  1255		(The above group chunk IDs may not be used for FORM type IDs.)
  1256		(Lower case letters and punctuation marks are forbidden in FORM 
  1257	type IDs.)
  1258		8SVX 8-bit sampled sound voice, ANBM animated bitmap, FNTR raster 
  1259	font, FNTV vector font, FTXT formatted text, GSCR general-use musical 
  1260	score, ILBM interleaved raster bitmap image, PDEF Deluxe Print page 
  1261	definition, PICS Macintosh picture, PLBM (obsolete), USCR Uhuru Sound 
  1262	Software musical score, UVOX Uhuru Sound Software Macintosh voice, 
  1263	SMUS simple musical score, VDEO Deluxe Video Construction Set video.
  1264	Data chunk IDs
  1265		"JJJJ", TEXT, PICT.
  1266	PROP LIST property IDs
  1267		OPGM, OCPU, OCMP, OSN, UNAM.
  1268	
  1269	
  1270	
  1271	Support Software
  1272	
  1273	These public domain C source programs are available for use in building 
  1274	IFF-compatible programs:
  1275	
  1276	IFF.H, IFFR.C, IFFW.C	
  1277	
  1278			IFF reader and writer package. 
  1279			These modules handle many of the details of reliably 
  1280			reading and writing IFF files.
  1281	
  1282	IFFCheck.C	This handy utility program scans an IFF file, checks 
  1283			that the contents are well formed, and prints an outline 
  1284			of the chunks.
  1285	
  1286	PACKER.H, Packer.C, UnPacker.C	
  1287	
  1288			Run encoder and decoder used for ILBM files.
  1289	
  1290	ILBM.H, ILBMR.C, ILBMW.C	
  1291	
  1292			Reader and writer support routines for raster image 
  1293			FORM ILBM. ILBMR calls IFFR and UnPacker. ILBMW calls 
  1294			IFFW and Packer.
  1295	
  1296	ShowILBM.C	
  1297			Example caller of IFFR and ILBMR modules. This 
  1298			Commodore-Amiga program reads and displays a FORM ILBM.
  1299	Raw2ILBM.C	
  1300			Example ILBM writer program. As a demonstration, it 
  1301			reads a raw raster image file and writes the image 
  1302			as a FORM ILBM file.
  1303	ILBM2Raw.C	
  1304			Example ILBM reader program.  Reads a FORM ILBM file
  1305			and writes it into a raw raster image.
  1306	
  1307	REMALLOC.H, Remalloc.c
  1308	
  1309			Memory allocation routines used in these examples.
  1310	
  1311	INTUALL.H	generic "include almost everything" include-file
  1312			with the sequence of includes correctly specified.
  1313	
  1314	READPICT.H, ReadPict.c	
  1315	
  1316			given an ILBM file, read it into a bitmap and 
  1317			a color map
  1318	
  1319	PUTPICT.H, PutPict.c 	
  1320	
  1321			given a bitmap and a color map, save it as
  1322			an ILBM file.
  1323	
  1324	GIO.H, Gio.c	generic I/O speedup package.  Attempts to speed
  1325			disk I/O by buffering writes and reads.
  1326	
  1327	giocall.c	sample call to gio.
  1328	
  1329	ilbmdump.c	reads in ILBM file, prints out ascii representation
  1330			for including in C files.
  1331	
  1332	bmprintc.c	prints out a C-language representation of data for
  1333			a bitmap.
  1334	
  1335	
  1336	
  1337	Example Diagrams
  1338	
  1339	Here's a box diagram for an example IFF file, a raster image FORM 
  1340	ILBM. This FORM contains a bitmap header property chunk BMHD, a color 
  1341	map property chunk CMAP, and a raster data chunk BODY. This particular 
  1342	raster is 320 x 200 pixels x 3 bit planes uncompressed. The "0" after 
  1343	the CMAP chunk represents a zero pad byte; included since the CMAP 
  1344	chunk has an odd length. The text to the right of the diagram shows 
  1345	the outline that would be printed by the IFFCheck utility program 
  1346	for this particular file.
  1347	
  1348		+-----------------------------------+
  1349		|'FORM'		24070		    |	FORM 24070 IBLM
  1350		+-----------------------------------+
  1351		|'ILBM'				    |
  1352		+-----------------------------------+
  1353		| +-------------------------------+ |
  1354		| | 'BMHD'	20		  | |	.BMHD  20
  1355		| | 320, 200, 0, 0, 3, 0, 0, ...  | |
  1356		| + ------------------------------+ |
  1357		| | 'CMAP'	21	          | |	.CMAP  21
  1358		| | 0, 0, 0; 32, 0, 0; 64,0,0; .. | |
  1359		| +-------------------------------+ |
  1360		| 0				    |
  1361		+-----------------------------------+
  1362		|'BODY'		24000		    |	.BODY 24000
  1363		|0, 0, 0, ...			    |
  1364		+-----------------------------------+
  1365	
  1366	This second diagram shows a LIST of two FORMs ILBM sharing a common 
  1367	BMHD property and a common CMAP property. Again, the text on the right 
  1368	is an outline  a la IFFCheck.
  1369	
  1370	
  1371	     +-----------------------------------------+
  1372	     |'LIST'		48114	       	       |  LIST  48114  AAAA
  1373	     +-----------------------------------------+
  1374	     |'AAAA'				       |  .PROP  62  ILBM
  1375	     |	+-----------------------------------+  |
  1376	     |  |'PROP'		62		    |  |  
  1377	     |  +-----------------------------------+  |
  1378	     |	|'ILBM'				    |  |
  1379	     |	+-----------------------------------+  |
  1380	     |	| +-------------------------------+ |  |
  1381	     |	| | 'BMHD'	20		  | |  |  ..BMHD  20
  1382	     |	| | 320, 200, 0, 0, 3, 0, 0, ...  | |  |
  1383	     |	| | ------------------------------+ |  |
  1384	     |	| | 'CMAP'	21	          | |  |  ..CMAP  21
  1385	     |	| | 0, 0, 0; 32, 0, 0; 64,0,0; .. | |  |
  1386	     |	| +-------------------------------+ |  |
  1387	     |	| 0				    |  |
  1388	     |	+-----------------------------------+  |
  1389	     |	+-----------------------------------+  |
  1390	     |	|'FORM'		24012		    |  |  .FORM  24012  ILBM
  1391	     |	+-----------------------------------+  |
  1392	     |	|'ILBM'				    |  |  
  1393	     |	+-----------------------------------+  |
  1394	     |	|  +-----------------------------+  |  |
  1395	     |	|  |'BODY'		24000    |  |  |  ..BODY  24000
  1396	     |	|  |0, 0, 0, ...		 |  |  |
  1397	     |	|  +-----------------------------+  |  |
  1398	     |	+-----------------------------------+  |
  1399	     |	+-----------------------------------+  |
  1400	     |	|'FORM'		24012		    |  |  .FORM  24012  ILBM
  1401	     |	+-----------------------------------+  |
  1402	     |	|'ILBM'				    |  |
  1403	     |	+-----------------------------------+  |
  1404	     |	|  +-----------------------------+  |  |
  1405	     |	|  |'BODY'		24000    |  |  |  ..BODY  24000
  1406	     |	|  |0, 0, 0, ...		 |  |  |
  1407	     |	|  +-----------------------------+  |  |
  1408	     |	+-----------------------------------+  |
  1409	     +-----------------------------------------+
  1410	
  1411	
  1412	
  1413	Appendix B. Standards Committee
  1414	
  1415	The following people contributed to the design of this IFF standard:
  1416	
  1417	Bob "Kodiak" Burns, Commodore-Amiga
  1418	R. J. Mical, Commodore-Amiga
  1419	Jerry Morrison, Electronic Arts
  1420	Greg Riker, Electronic Arts
  1421	Steve Shaw, Electronic Arts
  1422	Barry Walsh, Commodore-Amiga
