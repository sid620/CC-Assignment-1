     1	BIDIRECTIONAL ASSOCIATIVE MEMORY SYSTEMS IN C++
     2	by Adam Blum
     3	
     4	
     5	[LISTING ONE]
     6	
     7	////////////////////////////////////////////////////////////
     8	// BAM.HPP  Provide vector, matrix, vector pair, matrix, BAM matrix, and 
     9	// BAM system classes and methods to implement BAM system concept.
    10	// Extended note:
    11	// This is an implementation of the concept of Bidirectional
    12	// Associative Memories as developed by Bart Kosko and others. 
    13	// It includes the extended concept introduced by Patrick Simpson
    14	// of the "BAM System". Where reasonable Simpson's notation has been
    15	// been maintained. The presentation benefits greatly from C++ and OOP, in that
    16	// (I believe) it is both easier to understand than a "pseudocode" version, 
    17	// yet more precise (in that it works!)
    18	// Developed with Zortech C++ Version 2.0 -- Copyright (c) Adam Blum, 1989,90
    19	
    20	#include<stdlib.h>
    21	#include<io.h>
    22	#include<stdio.h>
    23	#include<string.h>
    24	#include<limits.h>
    25	#include<ctype.h>
    26	#include<stream.hpp>
    27	#include "debug.h" // debugging devices
    28	// where are Zortech's min,max?
    29	#define max(a,b)	(((a) > (b)) ? (a) : (b))
    30	#define min(a,b)	(((a) < (b)) ? (a) : (b))
    31	
    32	// will be changed to much higher than these values
    33	const ROWS=16;	// number of rows (length of first pattern)
    34	const COLS=8;	// number of columns (length of second pattern)
    35	const MAXMATS=10; // maximum number of matrices in BAM system
    36	const MAXVEC=16; // default size of vectors
    37	
    38	class matrix;
    39	class bam_matrix;
    40	class vec {
    41		friend class matrix;
    42		friend class bam_matrix;
    43		friend class bam_system;
    44			int n;
    45			int *v;
    46		public:
    47			// see BAM.CPP for implementations of these
    48			vec(int size=MAXVEC,int val=0); // constructor
    49			~vec();	// destructor
    50			vec(vec &v1); // copy-initializer
    51			int length();
    52			vec& operator=(const vec& v1); // vector assignment
    53			vec& operator+(const vec& v1); // vector addition
    54			vec& operator+=(const vec& v1); // vector additive-assignment
    55			vec& operator*=(int i); // vector multiply by constant
    56			// supplied for completeness, but we don't use this now
    57			int operator*(const vec& v1); // dot product
    58			vec operator*(int c); // multiply by constant
    59			// vector transpose multiply needs access to v array
    60			int operator==(const vec& v1);
    61			int& operator[](int x);
    62			friend istream& operator>>(istream& s,vec& v);
    63			friend ostream& operator<<(ostream& s, vec& v);
    64	}; //vector class
    65	
    66	class vecpair;
    67	
    68	class matrix {
    69		protected: 
    70		// bam_matrix (a derived class) will need to use these members
    71		// preferred to "friend class", since there may be many derived
    72		// classes which need to use this 
    73			int **m; // the matrix representation
    74			int r,c; // number of rows and columns
    75		public: 
    76			// constructors 
    77			matrix(int n=ROWS,int p=COLS); 
    78			matrix(const vec& v1,const vec& v2);
    79			matrix(const vecpair& vp);
    80			matrix(matrix& m1); // copy-initializer
    81			~matrix();
    82			int depth();
    83			int width();
    84			matrix& operator=(const matrix& m1);
    85			matrix& operator+(const matrix& m1);
    86			matrix& operator+=(const matrix& m1);
    87			vec colslice(int col); 
    88			vec rowslice(int row); 
    89			friend ostream& operator<<(ostream& s,matrix& m1);
    90	}; // matrix class
    91	
    92	class vecpair {
    93		friend class matrix;
    94		friend class bam_matrix;
    95		friend class bam_system;
    96			int flag; // flag signalling whether encoding succeeded
    97			vec a;
    98			vec b;
    99		public: 
   100			vecpair(int n=ROWS,int p=COLS); // constructor
   101			vecpair(const vec& A,const vec& B);
   102			vecpair(const vecpair& AB); // copy initializer
   103			~vecpair();    
   104			vecpair& operator=(const vecpair& v1);
   105			int operator==(const vecpair& v1);
   106			friend istream& operator>>(istream& s,vecpair& v);
   107			friend ostream& operator<<(ostream& s,vecpair& v);
   108			friend matrix::matrix(const vecpair& vp);
   109	};
   110	
   111	class bam_matrix: public matrix {
   112		private: 
   113			int K; // number of patterns stored in matrix
   114			vecpair *C; // actual pattern pairs stored
   115			int feedthru(const vec&A,vec& B);
   116			int sigmoid(int n); // sigmoid threshold function
   117		public: 
   118			bam_matrix(int n=ROWS,int p=COLS);
   119			~bam_matrix();
   120			// but we supply it with the actual matrix A|B (W is implied)
   121			void encode(const vecpair& AB); // self-ref version
   122			// uncode only necessary for BAM-system
   123			void uncode(const vecpair& AB); // self-ref version
   124			vecpair recall(const vec& A);
   125			int check(); 
   126			int check(const vecpair& AB);
   127			// Lyapunov energy function: E=-AWBtranspose
   128			int energy(const matrix& m1); // Lyapunov energy function
   129	}; // BAM matrix
   130	
   131	class bam_system {
   132			bam_matrix *W[MAXMATS];
   133			int M; // number of matrices
   134		public:
   135			bam_system(int M=1);
   136			~bam_system();
   137			void encode(const vecpair& AB);
   138			vecpair& recall(const vec& A);
   139			// train equiv. to Simpson's encode of all pairs
   140			void train(char *patternfile); 
   141			friend ostream& operator<<(ostream& s,bam_system& b);
   142	}; // BAM system class
   143	
   144	
   145	[LISTING TWO]
   146	
   147	///////////////////////////////////////
   148	// BAM.CPP Provide vector, matrix, vector pair, matrix, BAM matrix, and BAM 
   149	// system classes to implement BAM systems
   150	// Extended note:
   151	// This is an implementation of the concept of Bidirectional
   152	// Associative Memories as developed by Bart Kosko and others. 
   153	// It includes the extended concept introduced by Patrick Simpson
   154	// of the "BAM System". Where reasonable Simpson's notation has been
   155	// been maintained. The presentation benefits greatly from C++ and OOP, in that
   156	// (I believe) it is both easier to understand than a "pseudocode" version, 
   157	// yet more precise (in that it works!)
   158	// Developed with Zortech C++ Version 2.0 -- Copyright (c) 1989,90 Adam Blum
   159	
   160	#include"bam.hpp"
   161	
   162	///////////////////////////////////
   163	// vector class member functions
   164	
   165	vec::vec(int size,int val) { 
   166		v = new int[size]; 
   167		n=size;
   168		for(int i=0;i<n;i++)
   169			v[i]=0;
   170	} // constructor
   171	vec::~vec() { delete v;} // destructor
   172	vec::vec(vec& v1) // copy-initializer
   173	{
   174		v=new int[n=v1.n];
   175		for(int i=0;i<n;i++)
   176			v[i]=v1.v[i];
   177	}
   178	vec& vec::operator=(const vec& v1)
   179	{
   180		delete v;
   181		v=new int[n=v1.n];
   182		for(int i=0;i<n;i++)
   183			v[i]=v1.v[i];
   184		return *this;
   185	}
   186	vec& vec::operator+(const vec& v1)
   187	{
   188		vec sum(v1.n);
   189		sum.n=v1.n;
   190		for(int i=0;i<v1.n;i++)
   191			sum.v[i]=v1.v[i]+v[i];
   192		return sum;
   193	}
   194	vec& vec::operator+=(const vec& v1)
   195	{
   196		for(int i=0;i<v1.n;i++)
   197			v[i]+=v1.v[i];
   198		return *this;
   199	}
   200	vec vec::operator*(int c)
   201	{
   202		vec prod(length());
   203		for(int i=0;i<prod.n;i++)
   204			prod.v[i]=v[i]*c;
   205		return prod;	
   206	}
   207	int vec::operator*(const vec& v1) // dot-product
   208	{
   209		int sum=0;
   210		for(int i=0;i<min(n,v1.n);i++)
   211			sum+=(v1.v[i]*v[i]);
   212		//D(cout << "dot product " << *this << v1 << sum << "\n";)
   213		return sum;
   214	}
   215	int vec::operator==(const vec& v1) 
   216	{
   217		if(v1.n!=n)return 0;
   218		for(int i=0;i<min(n,v1.n);i++){
   219			if(v1.v[i]!=v[i]){
   220				return 0;
   221			}
   222		}
   223		return 1;
   224	}
   225	int& vec::operator[](int x)
   226	{
   227		if(x<length() && x>=0)
   228			return v[x];
   229		else
   230			cout << "vec index out of range";
   231	}
   232	int vec::length(){return n;} // length method
   233	
   234	istream& operator>>(istream& s,vec &v)
   235	// format: list of ints followed by ','
   236	{
   237		char c;
   238		v.n=0;
   239		v.v=new int[MAXVEC];
   240		for(;;){
   241			s>>c;
   242			if(s.eof())return s;		
   243			if(c==',')return s;
   244			if(isspace(c))continue;
   245			v.v[v.n++]=((c!='0')?1:-1);
   246		}
   247	}
   248	ostream& operator<<(ostream& s, vec& v)
   249	// format: list of ints followed by ','
   250	{
   251		for(int i=0;i<v.n;i++)
   252			s << (v.v[i]<0?0:1);
   253		s << ",";
   254		return s;
   255	}
   256	
   257	///////////////////////////////
   258	// matrix  member functions
   259	matrix::matrix(int n,int p) 
   260	{ 
   261		//D(cout << "Constructing " << n << " x " << p << " matrix.\n";)
   262		m=new int *[n];
   263		for(int i=0;i<n;i++){
   264			m[i]=new int[p];
   265			for(int j=0;j<p;j++)
   266				m[i][j]=0;
   267		}
   268		r=n; 
   269		c=p;
   270	} // constructor
   271	matrix::matrix(const vecpair& vp) 
   272	{
   273		//D(cout << "Constructing matrix from: " << vp;)
   274		r=vp.a.length();
   275		c=vp.b.length();
   276		m=new int *[r];
   277		for(int i=0;i<r;i++){
   278			m[i]=new int[c];
   279			for(int j=0;j<c;j++)
   280				m[i][j]=vp.a.v[i]*vp.b.v[j];
   281		}
   282	}// constructor 
   283	matrix::matrix(const vec& v1,const vec& v2) 
   284	{
   285		//D(cout << "Constructing matrix from " << v1 << v2 << "\n";)
   286		r=v1.length();
   287		c=v2.length();
   288		m=new int *[r];
   289		for(int i=0;i<r;i++){
   290			m[i]=new int[c];
   291			for(int j=0;j<c;j++)
   292				m[i][j]=v1.v[i]*v2.v[j];
   293		}
   294	}// constructor 
   295	matrix::matrix(matrix& m1) // copy-initializer
   296	{
   297		//D(cout << "matrix copy-initializer\n"; )
   298		r=m1.r;
   299		c=m1.c;
   300		m=new int *[r];
   301		for(int i=0;i<r;i++){
   302			m[i]=new int[c];
   303			for(int j=0;j<c;j++)
   304				m[i][j]=m1.m[i][j];
   305		}
   306	}
   307	matrix::~matrix() 
   308	{ 
   309		for(int i=0;i<r;i++)
   310			delete m[i];
   311		delete m;
   312	} // destructor
   313	matrix& matrix::operator=(const matrix& m1)
   314	{
   315		for(int i=0;i<r;i++)
   316			delete m[i];
   317		r=m1.r;
   318		c=m1.c;
   319		m=new int*[r];
   320		for(i=0;i<r;i++){
   321			m[i]=new int[c];
   322			for(int j=0;j<r;j++)
   323				m[i][j]=m1.m[i][j];
   324		}
   325		return *this;	    
   326	}
   327	matrix& matrix::operator+(const matrix& m1)
   328	{
   329		matrix sum(r,c);
   330		for(int i=0;i<r;i++)
   331			for(int j=0;j<r;j++)
   332				sum.m[i][j]=m1.m[i][j]+m[i][j];
   333		return sum;
   334	}
   335	matrix& matrix::operator+=(const matrix& m1)
   336	{
   337		//D(cout << "matrix additive assignment\n";)
   338		for(int i=0;i<r&&i<m1.r;i++)
   339			for(int j=0;j<c&&j<m1.c;j++)
   340				m[i][j]+=(m1.m[i][j]);
   341		return *this;
   342	}
   343	vec matrix::colslice(int col) 
   344	{
   345		vec temp(r); 
   346		for(int i=0;i<r;i++)
   347			temp.v[i]=m[i][col];
   348		return temp;
   349	}
   350	vec matrix::rowslice(int row) 
   351	{
   352		vec temp(c); 
   353		for(int i=0;i<c;i++)
   354			temp.v[i]=m[row][i];
   355		return temp;
   356	}
   357	int matrix::depth(){return r;}
   358	int matrix::width(){return c;}
   359	
   360	ostream& operator<<(ostream& s,matrix& m1)
   361	// print a matrix
   362	{
   363		for(int i=0;i<m1.r;i++){
   364			for(int j=0;j<m1.c;j++)
   365				s << m1.m[i][j] << " ";
   366			s << "\n";
   367		}
   368	}
   369	//////////////////////////////////////////
   370	// vecpair  member functions 
   371	// constructor
   372	vecpair::vecpair(int n,int p) { }
   373	vecpair::vecpair(const vec& A,const vec& B) {a=A;b=B;}
   374	vecpair::vecpair(const vecpair& AB) {*this=vecpair(AB.a,AB.b);}
   375	vecpair::~vecpair() {} // destructor
   376	vecpair& vecpair::operator=(const vecpair& v1)
   377	{
   378		a=v1.a;
   379		b=v1.b;
   380		return *this;
   381	}
   382	int vecpair::operator==(const vecpair& v1)
   383	{
   384		return 	(a == v1.a) && (b == v1.b);
   385	}
   386	istream& operator>>(istream& s,vecpair& v1)
   387	// input a vector pair
   388	{
   389		s>>v1.a>>v1.b;
   390		return s;
   391	}
   392	ostream& operator<<(ostream& s,vecpair& v1)
   393	// print a vector pair
   394	{
   395		return s<<v1.a<<v1.b<<"\n";
   396	}
   397	/////////////////////////////////
   398	//bam_matrix  member functions
   399	bam_matrix::bam_matrix(int n,int p):(n,p)
   400	{
   401		// the maximum number of pattern pairs storable
   402		// is around min(n,p) where n and p are 
   403		// the dimensionality of the matrix
   404		C=new vecpair[min(n,p)*2];
   405		K=0;
   406	}
   407	bam_matrix::~bam_matrix()
   408	{
   409	} // destructor
   410	void bam_matrix::encode(const vecpair& AB)
   411	// encode a pattern pair
   412	{
   413		//D(cout << "BAM Matrix encoding: " << AB;)
   414		matrix T(AB);
   415		(*this)+=T; // add the matrix transpose to the current matrix
   416		C[K]=AB;
   417		K++;
   418	}
   419	void bam_matrix::uncode(const vecpair& AB)
   420	// get rid of a stored pattern (by encoding A-B complement)
   421	{
   422		//D(cout << "uncode\n";)
   423		vec v=AB.b*-1;
   424		matrix T(AB.a,v); // T is A transpose B complement
   425		*this+=T;// add the matrix transpose to the current matrix
   426		K--;
   427	}
   428	vecpair bam_matrix::recall(const vec& A)
   429	// BAM Matrix recall algorithm (used by BAM SYSTEM recall)
   430	{
   431		int givenrow=(A.length()==width());
   432		D(cout<<"BAM matrix recall of" << A << givenrow?"(row)\n":"(col)\n";)
   433		vec B(givenrow?depth():width(),1);
   434		for(;;){ // feed vectors through matrix until "resonant" pattern-pair
   435			feedthru(A,B);
   436			if(feedthru(B,A))break; // stop when returned A = input A
   437		}	
   438		D(cout<< "resonant pair " << A << "\n and " << B << "\n";)
   439		if(givenrow)
   440			return vecpair(B,A);
   441		else
   442			return vecpair(A,B);
   443	}
   444	int bam_matrix::feedthru(const vec&A,vec& B)
   445	{
   446		//D(cout << "Feeding " << A << "\n"; )
   447		vec temp=B;int n;
   448		for(int i=0;i<B.length();i++){
   449			if(A.length()==width())
   450				n=sigmoid(A*rowslice(i));
   451			else
   452				n=sigmoid(A*colslice(i));
   453			if(n)
   454				B.v[i]=n;
   455		}
   456		return B==temp;
   457	}
   458	int bam_matrix::sigmoid(int n)
   459	// VERY simple (but classic one for BAM) threshold function
   460	//		
   461	//	      1	--------------
   462	//              |
   463	//  - -----------	   +
   464	//	     -1	
   465	{
   466		if(n<0)return -1;
   467		if(n>0)return 1;
   468		return 0;
   469	}
   470	int bam_matrix::check()
   471	// check to see if we have successfully encoded pattern-pair into this matrix
   472	{
   473		D(cout << "Check BAM matrix for " << K << " pattern pairs\n";)
   474		vecpair AB;
   475		for(int i=0;i<K;i++){
   476			AB=recall(C[i].a);
   477			if(!(AB==C[i])){
   478				D(cout <<"failed check\n ";)
   479				return 0;
   480			}
   481		}
   482		D(cout << "passed check\n ";)
   483		return 1;    
   484	}
   485	int bam_matrix::check(const vecpair& AB)
   486	{
   487		// different check routine for orthogonal construction BAM
   488		//check to see energy of present pattern pair to matrix
   489		// is equal to orthogonal BAM energy
   490		matrix T(AB);
   491		return energy(T)== -depth()*width();
   492	}
   493	int bam_matrix::energy(const matrix& m1)
   494	{
   495		int sum=0;
   496		for(int i=0;i<depth();i++)
   497			for(int j=0;j<width();j++)
   498				sum+=(m1.m[i][j]*this->m[i][j]);
   499		D(cout << "Energy of matrix " << -sum << "\n";)
   500		return -sum;
   501	}
   502	
   503	///////////////////////////////////////////
   504	// bam system  functions
   505	// top level of system (for now)
   506	
   507	// constructor
   508	bam_system::bam_system(int n)
   509	{
   510		M=n;
   511		for(int i=0;i<M;i++)
   512			W[i]=new bam_matrix;
   513	}
   514	bam_system::~bam_system() // destructor
   515	{
   516		for(int i=0;i<M;i++)
   517			delete W[i];
   518	}
   519	void bam_system::encode(const vecpair& AB)
   520	// encode the pattern pair AB into the BAOM system
   521	{
   522		D(cout << "BAM System encode\n";)
   523		for(int h=0;h<M;h++){
   524			W[h]->encode(AB);
   525			if(!W[h]->check())
   526				W[h]->uncode(AB);
   527			else 				
   528				break;			
   529		}
   530		if(h==M){ // all matrices full, add another
   531			if(h<MAXMATS){
   532				W[M]=new bam_matrix();
   533				W[M]->encode(AB);
   534				M++;
   535			}
   536			else{
   537				cout << "BAM System full\n";
   538				exit(1);
   539			}
   540		}
   541	}
   542	vecpair& bam_system::recall(const vec& A)
   543	// presented with pattern A, recall will return pattern-PAIR 
   544	{
   545		vecpair XY[MAXMATS];matrix *M1,*M2;
   546		int E,minimum=0,emin=INT_MAX;
   547		D(cout << "BAM System recall\n";)
   548		for(int h=0;h<M;h++){
   549			XY[h]=W[h]->recall(A);
   550			D(cout << h <<"-th matrix, returned vecpair "<< XY[h];)
   551			M1=new matrix(XY[h]);
   552			E=W[h]->energy(*M1);
   553			if(A.length()==W[h]->width())
   554				M2=new matrix(XY[h].a,A);
   555			else
   556				M2=new matrix(A,XY[h].b);
   557			if (  ( E-(W[h]->depth()*W[h]->width()) < emin )
   558		           && (E==W[h]->energy(*M2))
   559			)
   560			{
   561				emin=E-(W[h]->depth()*W[h]->width());
   562				minimum=h;						
   563			}
   564			delete M1;
   565			delete M2;
   566		}			
   567		return XY[minimum];
   568	}
   569	void bam_system::train(char *patternfile)
   570	// A "multiple-pair" encode - which Simpson calls "encode"
   571	// this could be used for initial BAM Sys training. However an up 
   572	// and running BAM Sys should only need to use "encode".
   573	{
   574		FILE *f=fopen(patternfile,"r");int n=0;
   575		filebuf sfile(f);
   576		istream s(&sfile,0);
   577		vecpair AB;
   578		for(;;){
   579			s >> AB;
   580			if(s.eof())break;
   581			D(cout << "Encoding " << n++ << "-th pattern pair:\n" << AB;)
   582			encode(AB);
   583		}
   584		D(cout << "Completed training from " << patternfile;)
   585	}
   586	ostream& operator<<(ostream& s,bam_system& b)
   587	// operator to print out contents of entire BAM system
   588	{
   589		for(int i=0;i<b.M;i++)
   590			s<< "BAM Matrix " << i << ": \n" << *(b.W[i]) << "\n";
   591	}
   592	
   593	
   594	[LISTING THREE]
   595	
   596	////////////////////////
   597	// TESTBAM.HPP
   598	// Interactive BAM System Demonstration Program. Used to verify BAM system 
   599	// algorithms and demonstrate them on an abstract (i.e. just 0s and 1s) case.
   600	// Developed with Zortech C++ 2.0 -- Copyright (c) 1989,90 Adam Blum
   601	
   602	#include"bam.hpp"
   603	
   604	vec v;
   605	vecpair AB;
   606	bam_system B;
   607	char *p;
   608	char patternfile[16]="TEST.FIL"; // file where test data is stored
   609	int trace=0; // SET TRACE=<whatever> at DOS prompt to turn trace on
   610	main()
   611	{
   612	     cout << "Interactive BAM System Demonstration\n";
   613	     trace=(p=getenv("TRACE"))?1:0;
   614	     cout << "Training from " << patternfile << "\n";
   615	     B.train(patternfile);
   616	     D(cout << "Resulting BAM System\n" << B;)
   617	     cout <<"Enter patterns as 0's and 1's terminated by comma.\n"
   618	     <<"Patterns must be length of " << ROWS << " or " << COLS <<".\n"
   619	     << "Null vector (just "","") to end.\n\n" ;
   620	     for(;;){
   621	          cout << "Enter pattern: ";
   622	          cin >> v;
   623	          if(!v.length())break;
   624	          if(v.length()!=ROWS && v.length()!=COLS){
   625	               cout << "Wrong length.\n";
   626	               continue;
   627	          }
   628	          AB=B.recall(v);
   629	          cout << "Recalled pattern pair\n" << AB;
   630	     }
   631	}
   632	
   633	
   634	[LISTING FOUR]
   635	
   636	
   637	1100101011010011,11101010,
   638	0110110111110110,11010101,
   639	1101111001010101,11110010,
   640	1010101000010111,11001101,
   641	0011001101011011,11110100,
   642	1100101011010011,11101010,
   643	0110100111110110,11010101,
   644	1101110101010101,11110010,
   645	1011101010010111,11001101,
   646	0001011101011011,11110100,
   647	1100101001010011,11101010,
   648	0110110110110110,11010101,
   649	1100111011010101,11110011,
   650	1010000100010111,11001101,
   651	0001101101011011,11110110,
   652	1100100011010011,11100110,
   653	0110110011110110,11010101,
   654	1101111001010101,11110011,
   655	1010100000011111,11001101,
   656	0001100101111011,11111000,
   657	1100101011010011,11011010,
   658	0010100111110110,11010101,
   659	1101111101010101,11110010,
   660	1010111000010111,11101101,
   661	0001000001011011,11110100,
   662	1100101011010011,11101010,
   663	0110110111110110,11010101,
   664	1101111000010101,11110110,
   665	1010100111010111,11001101,
   666	0001000101011011,11110100,
   667	0110110101110110,11010111,
   668	1101111001010101,11110110,
   669	1010111100110111,11001101,
   670	0001000101011011,11110100,
   671	1100101010010011,11101010,
   672	0110110111110110,11010101,
   673	1101111001010101,11110010,
   674	1010110000010111,11001101,
   675	0011000101011011,11110100,
   676	0011010101111011,10010111,
   677	
   678	
   679	[LISTING FIVE]
   680	
   681	# TESTBAM.MK
   682	# Make file for BAM System implementation tester
   683	# Uses Microsoft Make 
   684	# Compiler: Zortech C++ 2.0
   685	# To make with diagnostics enabled:
   686	# make CFLAGS="-DDEBUG=1" testbam.mk
   687	#
   688	
   689	CFLAGS=
   690	.cpp.obj: 
   691	     ztc -c $(CFLAGS) $*.cpp
   692	bam.obj: bam.cpp bam.hpp
   693	testbam.obj: testbam.cpp bam.hpp
   694	testbam.exe: testbam.obj bam.obj
   695	     blink testbam bam;
   696	
   697	
   698	
   699	
   700	
   701	
   702	