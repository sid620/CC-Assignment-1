     1	Performance Comparison Intel 386DX, Intel RapidCAD, C&T 38600DX, Cyrix 486DLC
     2	
     3	This document, containing descriptions and a benchmark comparison of the
     4	Intel 386DX, Intel RapidCAD, C&T 38600DX, and the Cyrix 486DLC has been
     5	put together for the benefit of the net.community. I believe, but cannot
     6	guarantee, that all data given herein is correct. If you would like to
     7	report errors in this document, or have suggestions for its enhancement,
     8	feel free to contact me at the following email address:
     9	
    10	     JUFFA@IRA.UKA.DE
    11	
    12	You can also write to me at my snail mail address:
    13	
    14	     Norbert Juffa
    15	     Wielandtstr. 14
    16	     7500 Karlsruhe 1
    17	     Germany
    18	
    19	Corrections pertaining to spelling or grammatical errors are also encouraged,
    20	especially from those net.users that are native speakers of (American) English.
    21	
    22	
    23	This is the third version of this document. Thanks to the people that helped
    24	improve it by their comments on the previous versions:
    25	
    26	    Alex Martelli (martelli@cadlab.sublink.org),
    27	    Fred Dunlap (fred@cyrix.com),
    28	    Antony Suter (antony@werple.apana.org.au)
    29	
    30	A special thanks for editing this article goes to:
    31	
    32	    David Ruggiero (osiris@halcyon.halcyon.com)
    33	
    34	
    35	The previous version of this article has also appeared in print. Check out:
    36	
    37	    Juffa, N.: "Performance Comparison Intel 386DX, Intel RapidCAD, C&T 38600DX,
    38	    Cyrix 486DLC". In: Association Francaise des Utilisateurs d'Unix et des
    39	    Systemes Ouverts (ed.): "Dossier special No 4 - Benchmarks", March 1993,
    40	    pp. 109-117
    41	
    42	
    43	This document released 14-June-1993
    44	
    45	---------------------------------------------------------------------------
    46	
    47	In 1992, three new CPUs were introduced into the PC marketplace. Each has the
    48	capability to replace the standard Intel 386DX CPU and provide higher
    49	performance for existing 386 systems. These new chips are the Intel RapidCAD,
    50	the Chips&Technologies (C&T) Super386 38600DX, and the Cyrix 486DLC. All chips
    51	had initially been released in 33 MHz versions, but at least the Cyrix 486DLC
    52	is available in a 40 MHz version now. While the Intel RapidCAD is marketed
    53	only as an end-user product (which means PC manufacturers will not ship systems
    54	with the RapidCAD already installed), C&T sells their products directly to the
    55	end user as well as to PC motherboard manufacturers. Cyrix currently sells
    56	only to OEMs (Original Equipment Manufacturers), that is motherboard
    57	manufacturers. Cyrix also manufactures the 486SLC, which is a replacement for
    58	the Intel/AMD 386SX CPUs. C&T has announced a 38600SX chip, but it will not
    59	ship before sometime in 1993, if at all.
    60	
    61	The Intel RapidCAD
    62	------------------
    63	
    64	The Intel RapidCAD is, in rough terms, an Intel 486DX with the 8 KB on-chip
    65	cache removed and a 386 pinout. To software, it appears to be a 386DX with a
    66	math coprocessor, as the 486-specific instructions have been removed from its
    67	instruction set. It is marketed by Intel as "the ultimate coprocessor" and, as
    68	the name implies, its main purpose is to replace the 386DX in existing systems
    69	and thereby boost the performance of floating-point intensive applications such
    70	as CAD software, spreadsheets, and math packages (e.g. SPSS, Mathematica).
    71	
    72	RapidCAD is delivered as a set of two chips. RapidCAD-1 is a 132-pin PGA (pin
    73	grid array) chip that goes into the CPU socket and replaces the 386DX. It
    74	contains the CPU and the FPU (floating-point unit). RapidCAD-2 is a 68-pin PGA
    75	chip that goes into the 387 coprocessor (or EMC) socket; it contains a simple
    76	PLA whose only purpose it to generate the FERR signal for the motherboard
    77	logic: this provides full PC-compatible handling of floating-point exceptions.
    78	Many CPU instructions execute in one clock cycle in the RapidCAD, just as on
    79	the Intel 486. The RapidCAD is constrained, however, by use of the standard
    80	386DX bus interface, since every bus cycle takes two CPU clock cycles. This
    81	means that instructions may be executed by the RapidCAD faster than they can be
    82	fetched from memory. But as most FPU instructions take longer to execute than
    83	CPU instructions, they are not greatly slowed down by this slow bus interface,
    84	and most of them execute in the same time as in the Intel 486DX. Therefore, the
    85	Intel RapidCAD provides higher overall floating-point performance than any
    86	386/387 combination. Results from the SPEC benchmarks, a common workstation
    87	UNIX benchmark suite, show that the RapidCAD provides 85% more floating-point
    88	and 15% more integer performance than an Intel 386DX/387DX combination at the
    89	same clock frequency.
    90	
    91	Power consumption of the RapidCAD is typically 3500 mW at 33 MHz. The current
    92	street price of the 33 MHz version is ~300 US$.
    93	
    94	The C&T 38600DX
    95	---------------
    96	
    97	The Chips&Technologies 38600DX is designed to be 100% compatible to the Intel
    98	386DX CPU. Unlike AMD's Am386 CPUs (which use microcode that is identical to
    99	the Intel 386DX's microcode), the C&T 38600DX uses new microcode developed
   100	within C&T using "clean-room" techniques. C&T even included the 386DX's
   101	"undocumented" LOADALL386 instruction in the instruction set to provide full
   102	compatibility with the Intel chip.
   103	
   104	Some instructions execute faster on the 38600DX than on the 386DX. C&T also
   105	produces a 38605DX CPU that includes a 512-byte instruction cache and provides
   106	further performance increases over the Intel part. The 38605DX needs a bigger
   107	socket (144-pin PGA) and is therefore *not* pin-compatible with the 386DX.
   108	
   109	In my tests, I found that the 38600DX has severe problems with the CPU-
   110	coprocessor communication, which causes its floating-point performance to drop
   111	below the level provided by the Intel 386DX/Intel 387DX for most programs. This
   112	problem exists with all available 387 compatible coprocessors (ULSI 83C87, IIT
   113	3C87, Cyrix EMC87, Cyrix 83D87, Cyrix 387+, C&T 38700, and the Intel 387DX).
   114	(A net.acquaintance also did tests with the 38600DX and arrived at similar
   115	results. He contacted C&T and they said they were aware of the problem.)
   116	
   117	Typical power consumption of the 40 MHz 38600DX is 1650 mW, which is less than
   118	the typical power consumption of the Intel 386DX at 33 MHz (2000 mW). The
   119	38600DX currently sells for ~US$ 80 for the 33 MHz version.
   120	
   121	The Cyrix 486DLC
   122	----------------
   123	
   124	The Cyrix 486DLC is the latest entry into the market of 386DX replacements. It
   125	features a 486SX compatible instruction set, a 1 KB on-chip cache, and a 16x16-
   126	bit hardware multiplier. The RISC-like execution unit of the 486DLC executes
   127	many instructions in a single clock cycle. The hardware multiplier multiplies
   128	16-bit quantities in 3 clock cycles, as compared to 12-25 cycles on a standard
   129	Intel 386DX. This is especially useful in address calculations (code from non-
   130	optimizing compilers may contain many MUL instructions for array accesses) and
   131	for software floating-point arithmetic (e.g., a coprocessor emulator). The 1 KB
   132	cache helps the 486DLC to overcome the limitations of the 386 bus interface,
   133	although its hit rate averages only about 65% under normal program conditions.
   134	
   135	In existing 386 systems, DMA transfers (such as those performed by a SCSI
   136	controller or a sound board) may force the internal cache of the 486DLC to be
   137	flushed as the only means available in a 386 system to enforce consistency
   138	between the contents of the on-chip cache and external memory. This stems from
   139	the fact that the 386 bus interface was designed without provisions for an
   140	on-chip cache. This problem can reduce the performance of the 486DLC in systems
   141	that do a sizeable amount of (bus master) DMA. Cyrix has, however, defined some
   142	additional cache control signals for some of the 486DLC lines; they can be used
   143	to improve communications between the on-chip cache and a larger external cache
   144	or main memory and prevent this problem. Current 386 systems ignore these
   145	signals since they are not defined for the Intel 386DX. However, motherboards
   146	designed for use with the Cyrix chip should be able to take advantage of them
   147	and thereby gain increased performance.
   148	
   149	The Cyrix cache is a unified data/instruction write-through type and can be
   150	configured as either a direct-mapped or 2-way set associative cache. It permits
   151	definition of up to four non-cacheable regions, which are particularly useful
   152	if a system has memory mapped peripherals (e.g., the Weitek math coprocessor).
   153	For compatibility reasons, the cache is disabled after a processor reset
   154	and must be enabled with the help of a small program provided by Cyrix. This
   155	prevents problems with BIOSes that are not "486DLC aware". Motherboards that
   156	come with the 486DLC installed usually feature a BIOS that supports the cache
   157	and switch it on after the machine self-test. On these machines, no additional
   158	software is required to take advantage of the cache. The cache control program
   159	from Cyrix is a DOS program. Antony Suter (antony@werple.apana.org.au) informs
   160	me that public domain drivers for OS/2, 386BSD, and Linux that enable the
   161	cache are available from various ftp servers.
   162	
   163	Not all 486DLCs will work correctly with all math coprocessors in all
   164	circumstances, with protected mode multitasked environments (e.g. MS-Windows
   165	386-enhanced mode) being especially critical. Using the 486DLC with the Cyrix
   166	EMC87, Cyrix 83D87 (chips produced prior to November 1991), and IIT 3C87, I
   167	have been able to completely lock up the machine due to synchronization
   168	problems between the CPU and the coprocessor while executing the FSAVE or
   169	FRSTOR instructions (which are used to save and restore the coprocessor status
   170	during task switches). According to Cyrix, this problem only occurred with the
   171	first revision of the 486DLC (like the sample chip I have) and is fixed on
   172	newer ones. To be on the safe side, the 486DLC should best be used with the
   173	Cyrix 387+ (its "Europe-only" name) or with the identical Cyrix 83D87
   174	(US-bound chips manufactured after October 1991): these are not only the
   175	highest performing 387 coprocessors on the market, but they also work properly
   176	even with the first generation 486DLC.
   177	
   178	If you already have a Cyrix 83D87 coprocessor and want to know whether it is
   179	the old or new type, I recommend you use my COMPTEST program, available as
   180	CTEST259.ZIP via anonymous ftp from garbo.uwasa.fi and other fine ftp servers.
   181	If COMPTEST reports a 387+, you either have the 387+ or the identical newer
   182	version of the 83D87 installed and can use any version of the Cyrix 486DLC
   183	without problems. If you believe that you may have problems with a 486DLC/387
   184	combination, I suggest you contact Cyrix technical support (1-800-FAS-MATH in
   185	the US).
   186	
   187	Power consumption of a 40 MHz 486DLC is typically 2800 mW. As Cyrix can't fill
   188	demand for their 486DLC/SLC chips, they currently sell these chips only to
   189	OEMs. About two million 486SLC/DLC CPUs have been sold so far. The 486SLC is
   190	especially popular with notebook manufacturers. Chips sold by retailers seem
   191	to be "surplus" chips sold off by OEMs at a premium price. While the price for
   192	a 486DLC-40 is about US$ 100 when bought by an OEM, it sells for about US$
   193	200-250 on the open market.
   194	
   195	Tests and benchmarks
   196	--------------------
   197	
   198	HW configuration: 33.3/40 MHz motherboard with Forex chip set and AMI BIOS. 128
   199	KB zero- wait-state, direct mapped, write-through CPU cache with one write
   200	buffer, 4 bytes per cache line, and 4 clock cycles penalty for a cache line
   201	miss. 8 MB of main memory with an average access time of 1.6 wait states. Cyrix
   202	EMC87 in 387 compatibility mode as math coprocessor. (This and the Cyrix 83D87
   203	/ 387+ are the fastest coprocessors available for use with the
   204	386DX/486DLC/38600DX). Conner 3204F hard disk, 203 MB capacity, IDE interface
   205	(CORETEST throughput 1100 KB/s, seek time 16 ms). Diamond SpeedSTAR HiColor,
   206	ISA bus SVGA card using Tseng's ET4000 chip, 1 MB DRAM as frame buffer, *no*
   207	accelerator. The switches on the card were set for fastest reliable operation,
   208	with a VIDSPEED throughput of 6500 bytes/ms at 40 MHz and 5400 bytes/ms at
   209	33.3 MHz.
   210	
   211	SW configuration: MS-DOS 5.0, MS Windows 3.1, HyperDisk 4.32 disk cache program
   212	in write-back mode, using 2 MB of extended memory, 386MAX 6.01 used as memory
   213	manager and DPMI provider in some benchmarks. Latest Tseng (Colorview) driver
   214	for Windows 3.1 at 1024x768x256, using the 8514 fonts.
   215	
   216	
   217	For the Whetstone, Dhrystone, WINTACH, DODUC, LINPACK, LLL, and Savage
   218	benchmarks, *higher* numbers indicate *faster* performance.
   219	
   220	For the MAKE RTL, MAKE TRANCK, and String-Test benchmarks, *lower* numbers
   221	indicate *faster* performance.
   222	
   223	
   224	                         Intel        C&T      Intel      Cyrix      Cyrix
   225	33.3 MHz                 386DX    38600DX   RapidCAD      486DLC     486DLC
   226	                                                        cache off    cache on
   227	integer
   228	
   229	Whetstone [kWhets/s]       447        585        563        695        803
   230	Dhrystone (C) [Dhry./s]  11688      11819      12357      14150      15488
   231	Dhrystone (Pas) [Dhry./s]10455      10877      10751      12154      13858
   232	String-Test [ms]           459        453        441        347        327
   233	MAKE RTL [s]                51.32      47.10      46.34      43.45      39.13
   234	MAKE TRANCK [s]             62.42      55.47      55.37      53.64      46.12
   235	WINTACH [overall RPM]        4.85       4.90       5.49       5.53       6.14
   236	
   237	float
   238	
   239	DODUC [Rapidity index]      79.0       76.4      150.3       89.4       90.7
   240	LINPACK [MFLOPS]             0.2808     0.2707     0.4578     0.3158     0.3438
   241	LLL [MFLOPS]                 0.3352     0.3537     0.6083     0.3816     0.4139
   242	Whetstone [kWhets/s]      2540       2340       3990       2908       3061
   243	Savage [function eval/s] 71685      53191      72464      88757      93897
   244	
   245	
   246	                         Intel        C&T      Intel      Cyrix      Cyrix
   247	40.0 MHz                 386DX    38600DX   RapidCAD      486DLC     486DLC
   248	                                                         cache off   cache on
   249	integer
   250	
   251	Whetstone [kWhets/s]       536        702        676        835        963
   252	Dhrystone (C) [Dhry./s]  14128      14116      14836      16987      18750
   253	Dhrystone (Pas) [Dhry./s]12490      13067      12890      14573      16624
   254	String-Test [ms]           384        377        368        289        273
   255	MAKE RTL [s]                43.46      40.11      39.84      37.25      33.54
   256	MAKE TRANCK [s]             53.00      47.59      47.07      45.36      39.00
   257	WINTACH [overall RPM]        5.65       5.73       6.41       6.46       7.23
   258	
   259	float
   260	
   261	DODUC [Rapidity index]      94.9       77.5      180.3      105.1      106.6
   262	LINPACK [MFLOPS]             0.3324     0.3260     0.5418     0.3789     0.4131
   263	LLL [MFLOPS]                 0.4025     0.4204     0.7263     0.4562     0.4956
   264	Whetstone [kWhets/s]      3061       2632       4798       3505       3677
   265	Savage [function eval/s] 86083      49587      86957     106762     112360
   266	
   267	
   268	To complete the picture, I ran the CPU/FPU standard benchmarks on an Intel
   269	486DX running at 33.3/40 MHz. Since the 486 machine was configured with a
   270	different hard disk than the 386 system, and the compilers and tools installed
   271	on the 386 machine were not present, the MAKE benchmarks could unfortunately
   272	not be included in the tests.
   273	
   274	486DX, 256 KBytes CPU cache (write-through), 8 MB of RAM, AMI-BIOS, Diamond
   275	SpeedSTAR HiColor (VIDSPEED throughput: 6500 bytes/ms at 40 MHz and 5400
   276	bytes/ms at 33.3 MHz), MS-DOS 5.0, MS-Windows 3.1:
   277	
   278	integer                       33.3 MHz             40 MHz
   279	
   280	Whetstone [kWhets/s]          707                 848
   281	Dhrystone (C) [Dhry./s]     19394               23265
   282	Dhrystone (Pas) [Dhry./s]   16978               20368
   283	String-Test [ms]              333                 279
   284	WINTACH                         8.59               10.14
   285	
   286	float
   287	
   288	DODUC [Rapidity index]        184.0              220.7
   289	LINPACK [MFLOPS]                0.6682              0.8204
   290	LLL [MFLOPS]                    0.9387              1.1110
   291	Whetstone [kWhets/s]         5143                6195
   292	Savage [function eval/s]    82192               98522
   293	
   294	
   295	Conclusions
   296	-----------
   297	
   298	The Cyrix 486DLC is the 386DX replacement with the highest integer performance.
   299	With the internal cache enabled, integer performance of the 486DLC can be up to
   300	80% higher compared with a Intel 386DX at the same clock frequency, with the
   301	average speed gain for integer applications being 35%. Enabling the internal
   302	cache provides about 5-15% more performance than with the cache disabled for
   303	both integer and floating-point applications. Floating-point applications are
   304	accelerated by about 15%-30% if the Cyrix 486DLC (with cache enabled) is used
   305	instead of the Intel 386DX. Compared with the Intel 486DX, the Cyrix 486DLC
   306	provides about 70% of the integer performance and about 50% of the floating-
   307	point performance at the same clock frequency.
   308	
   309	The Intel RapidCAD is the 386DX replacement that provides the highest floating-
   310	point performance. It can speed up most floating-point intensive programs by
   311	60%-90% compared with the fastest Intel 386DX/math coprocessor combination; it
   312	provides nearly 75% of the floating-point performance of a Intel 486DX at the
   313	same clock frequency. Integer performance increases by an average 15% by using
   314	the RapidCAD instead of the standard Intel 386DX, with the maximum performance
   315	gain being 35%.
   316	
   317	The Chips&Technologies 38600DX has a slightly higher integer performance than
   318	the Intel 386DX, with the speedup ranging from 0%-30% and an average speedup on
   319	the order of 10%.
   320	
   321	
   322	Description of benchmarks
   323	-------------------------
   324	DHRYSTONE [9] is a synthetic benchmark developed by R. Weicker from Siemens in
   325	1984. The frequency of operations and data types used by Dhrystone are modeled
   326	after statistics collected for 'typical' programs that are written in a HLL
   327	(high level language) such as C or Pascal that do not use floating-point
   328	arithmetic. Thus there is a certain distribution of global and local variables
   329	being used in procedures, there is a certain percentage of use of records
   330	(structs) or strings out of the total number of variables accessed and there is
   331	a certain percentage of procedure calls and if-statements out of the total
   332	lines of codes executed. All these percentages match the statistics used in the
   333	development of Dhrystone quite closely. To preserve the typical distributions,
   334	the measurement rules for Dhrystone forbid function inlining (a frequently used
   335	optimization technique optionally performed by most optimizing compilers). The
   336	current version of Dhrystone is 2.1, and this is the version used for my tests.
   337	Version 2.1 [10] differs from previous versions in that it contains additional
   338	code that prevents optimizing compilers from throwing out most of the code by
   339	dead code elimination (since Dhrystone has no input file, many expressions can
   340	be computed at compile time), thus artificially inflating performance numbers.
   341	The Dhrystone benchmark exists in equivalent Ada, Pascal and C versions, which
   342	are all available from netlib@ornl.gov. Dhrystone measures the time to execute
   343	its main loop and sets this time into relation with a fixed reference time, the
   344	result being a performance index given in "Dhrystones per second". I used two
   345	Dhrystone executables. One was compiled using the non-optimizing Turbo Pascal
   346	6.0 compiler, the other one was compiled with the MS-C 7.0 compiler using the
   347	large memory model and maximum optimization but without the use of function
   348	inlining. Because the Turbo Pascal executable uses more memory operands and the
   349	MS-C executable uses more register-to-register operations, the speedup for the
   350	executables on different CPUs can be noticeably different.
   351	
   352	WINTACH is a public domain benchmark program by Texas Instruments that measures
   353	the speed of graphics output for four typical MS-Windows applications: a word
   354	processor, a spreadsheet, a CAD program, and a paint program. TI has collected
   355	profiles for each class of applications under 'typical' user loads. The four
   356	parts of the WINTACH benchmark were then modeled after these profiles, so that
   357	the percentage of certain GDI (graphics device interface) calls found in the
   358	profiles is also present in the benchmark. WINTACH determines the performance
   359	of each program part relative to the performance of a standard VGA card in a 20
   360	MHz 386DX machine. It also combines the four values into an overall relative
   361	performance index, which is reported in my tables. Using this single number to
   362	represent graphics performance is justified in this case since the four partial
   363	results do *not* deviate much from the average for the SVGA tested (a Diamond
   364	SpeedSTAR HiColor). I used a frame buffer card for the test because for these
   365	graphics card type, graphics performance depends solely on the performance of
   366	the CPU, which handles all accesses to the display memory. On an accelerated
   367	card, some of the low-level operations are delegated to the accelerator chip
   368	and the influence of the CPU speed on the graphics performance is not seen so
   369	clearly. For this test, I used the latest Tseng Windows 3.1 driver (Colorview)
   370	at a resolution of 1024x768x256 with the large 8514 fonts (WINTACH code C8).
   371	
   372	MAKE RTL is not a single program. Rather it is a build of a complete project,
   373	my own run-time library for Turbo Pascal 6.0. The project consists of about 200
   374	source files with a total size of ~650 KByte. Most of the source files are
   375	assembly language (.ASM) files, while there are also some Pascal (.PAS) files.
   376	Building the complete project using MAKE, about 200 binary files (.OBJ and
   377	.TPU) are produced with a combined size of ~300 KB. The programs used during
   378	the build are MAKE 3.5, TPC 6.01, and TASM 2.01, all by Borland, Inc. All files
   379	are read from and written to the hard disk, using a 2 MB write back disk cache
   380	provided by the HyperDisk 4.32 program. This eliminates most of the I/O
   381	overhead. No memory manager was installed during the test. The time reported is
   382	the time from starting the MAKE utility to the reappearance of the DOS prompt.
   383	MAKE RTL can be thought of being typical of applications that operate on a lot
   384	of small files, and use only integer instructions.
   385	
   386	MAKE TRANCK is a project build for a project consisting of two assembly
   387	language modules, two C modules and one FORTRAN module. The combined size of
   388	the source files is approximately 120 KBytes. All modules are compiled
   389	(assembled) and combined into a single program linking with both, the C and the
   390	FORTRAN libraries. Programs used are MAKE 3.5 by Borland and MASM 6.0, MS-C
   391	7.0, MS-FORTRAN 5.0, and LINK 5.3, all by Microsoft, Inc. The C compiler and
   392	the linker run in protected mode and require a DPMI host to be present. 386MAX
   393	6.01 by Qualitas was installed for this purpose. To minimize I/O overhead, the
   394	HyperDisk 4.32 disk caching program was installed, with 2 MByte of extended
   395	memory allocated to the cache. The modules are compiled with compiler switches
   396	set for maximum optimization, and most of the time for the project build is
   397	spent in the optimizing stages of the compilers.
   398	
   399	STRING-TEST is a simple benchmark that tests the string handling functions
   400	built into the Turbo Pascal language. Nearly all of the execution time is spent
   401	in repeated execution of the STOS, CMPS, SCAS, and MOVS instructions. The data
   402	and code fit into about five KBytes of memory. In cached systems, almost all
   403	memory accesses will be cache hits. The program was written and compiled with
   404	Turbo Pascal 6.0 and linked with my own run-time library, which provides much
   405	faster string functions than the run-time library delivered by Borland.
   406	Compiler switches were set for fastest execution. The time reported is the time
   407	to complete the whole benchmark in milliseconds, with an accuracy of +/-1
   408	millisecond.
   409	
   410	LLL is short for Lawrence Livermore Loops [8], a set of kernels taken from real
   411	floating-point extensive programs. Some of these loops are vectorizable, but
   412	since we don't deal with vector processors here, this doesn't matter. For this
   413	test, LLL was adapted from the FORTRAN original in [7] to Turbo Pascal. By
   414	variable overlaying (similar to FORTRAN's EQUIVALENCE statement) memory
   415	allocation for data was reduced to 64 KB, so all data fits into a single 64 KB
   416	segment. The older version of LLL is used here which contains 14 loops. There
   417	also exists a newer, more elaborate version consisting of 24 kernels. The
   418	kernels in LLL exercise only multiplication and addition. The MFLOPS rate
   419	reported is the average of the MFLOPS rate of all 14 kernels as reported by the
   420	LLL program. All floating-point variables in the program are of type double.
   421	LLL and Whetstone results (see below) are reported as returned by my COMPTEST
   422	test program in which they have been included as a measure of coprocessor/FPU
   423	performance. COMPTEST has been compiled under Turbo Pascal 6.0 with all
   424	'optimizations' on and using my own run-time library, which gives higher
   425	performance than the one included with TP 6.0. My library is available as
   426	TPL60N19.ZIP from garbo.uwasa.fi and ftp-sites that mirror this site.
   427	
   428	LINPACK [4] is a well known floating-point benchmark that also heavily
   429	exercises the memory system. Linpack operates on large matrices and takes up
   430	about 570 KB in the version used for this test. This is about the largest
   431	program size a pure DOS system can accommodate. Linpack was originally designed
   432	to estimate performance of BLAS, a library of FORTRAN subroutines that handles
   433	various vector and matrix operations. Note that vendors are free to supply
   434	optimized (e.g. assembly language versions) of BLAS. Linpack uses two routines
   435	from BLAS which are thought to be typical of the matrix operations used by
   436	BLAS. Both routines only use addition/subtraction and multiplication. The
   437	FORTRAN source code for Linpack can be obtained from the automated mail server
   438	netlib@ornl.gov. Linpack was compiled using MS FORTRAN 5.0 in the HUGE memory
   439	model (which can handle data structures larger than 64 KB) and with compiler
   440	switches set for maximum optimization. All floating-point variables in the
   441	program are of the DOUBLE type. Linpack performs the same test repeatedly. The
   442	number reported is the maximum MFLOPS rate returned by Linpack. Linpack MFLOPS
   443	ratings for a great number of machines are contained in [5]. This PostScript
   444	document is also available from netlib@ornl.gov.
   445	
   446	WHETSTONE [1,2,3] is a synthetic benchmark based on statistics collected about
   447	the use of certain control and data structures in programs written in high
   448	level languages. Based on these statistics, Whetstone tries to mirror a
   449	'typical' HLL program. Whetstone performance is expressed by how many
   450	hypothetical 'whetstone' instructions are executed per second. It was originally
   451	implemented in ALGOL. Unlike LLL and Linpack, Whetstone not only uses addition
   452	and multiplication but exercises all basic arithmetic operations as well as
   453	some transcendental functions. Whetstone performance depends on the speed of
   454	the coprocessor as well as on the speed of the CPU, while LLL and Linpack place
   455	a heavier burden on the coprocessor/FPU. There exist an old and a new version
   456	of Whetstone. Note that results from the two versions can differ by as much as
   457	20% for the same test configuration. For this test, the new version in Pascal
   458	from [2] was used. It was compiled with Turbo Pascal 6.0 and my own library
   459	(see above) with all 'optimizations' on. For the integer test, software
   460	floating-point arithmetic using the REAL type was utilized. Using the software
   461	arithmetic exercises only the CPU, in particular the execution of MOV, SHL, SHR,
   462	RCR, ADD, SUB, MUL, and DIV instructions. For the floating-point test, the
   463	hardware floating-point arithmetic of the coprocessor was used and computations
   464	were performed using the DOUBLE type.
   465	
   466	SAVAGE tests the performance of transcendental function evaluation. It is
   467	basically a small loop in which the sin, cos, arctan, ln, exp, and sqrt
   468	functions are combined in a single expression. While sin, cos, arctan, and sqrt
   469	can be evaluated directly with a single 387 coprocessor instruction each, ln
   470	and exp need additional preprocessing for argument reduction and result
   471	conversion. According to [11], the Savage benchmark was devised by Bill Savage,
   472	and is distributed by: The Wohl Engine Company, Ltd., 8200 Shore Front Parkway,
   473	Rockaway Beach, NY 11693, USA. Usually, Savage is programmed to make 250,000
   474	passes though the loop. Here only 10,000 loops are executed for a total of
   475	60,000 transcendental function evaluations. The result is expressed in function
   476	evaluations per second. SAVAGE source code was taken from [6] and compiled with
   477	Turbo Pascal 6.0 and my own run-time library (see above).
   478	
   479	DODUC [12] is a modified application program by Nhuan Doduc that is also part
   480	of the SPEC benchmark suite. It is a nuclear safety analysis code that
   481	simulates the time evolution of a thermohydraulic modelization for a nuclear
   482	reactor's component and the benchmark is created from the computational kernel
   483	of the original application. The benchmark consists of 5323 FORTRAN statement
   484	lines and the executable size is about 350 KBytes. Almost all processing is
   485	done using double precision floating-point values. There is not much array
   486	processing. Instead the program has an iterative structure with an abundance of
   487	short branches and small loops. The version used for this test was compiled
   488	with the highly optimizing NDP FORTRAN V3.0 compiler from Microway, which
   489	generates a 32-bit mode executable that runs in protected mode using a
   490	protected mode loader provided by Microway. The execution time of the DODUC
   491	program is set into relation with fixed reference times and the result is
   492	scaled to give a "Rapidity index".
   493	
   494	
   495	References
   496	----------
   497	
   498	[1]  Curnow, H.J.; Wichmann, B.A.: A synthetic benchmark.
   499	     Computer Journal, Vol. 19, No. 1, 1976, pp. 43-49
   500	[2]  Wichmann, B.A.: Validation code for the Whetstone benchmark.
   501	     NPL Report DITC 107/88, National Physics Laboratory, UK, March 1988
   502	[3]  Curnow, H.J.: Wither Whetstone? The Synthetic Benchmark after 15 Years.
   503	     In: Aad van der Steen (ed.): Evaluating Supercomputers.
   504	     London: Chapman and Hall 1990
   505	[4]  Dongarra, J.J.: The Linpack Benchmark: An Explanation.
   506	     In: Aad van der Steen (ed.): Evaluating Supercomputers.
   507	     London: Chapman and Hall 1990
   508	[5]  Dongarra, J.J.: Performance of Various Computers Using Standard Linear
   509	     Equations Software.
   510	     Report CS-89-85, Computer Science Department, University of Tennessee,
   511	     March 11, 1992
   512	[6]  Huth, N.: Dichtung und Wahrheit oder Datenblatt und Test.
   513	     Design & Elektronik 1990, Heft 13, Seiten 105-110
   514	[7]  Esser, R.; Kremer, F.; Schmidt, W.G.: Testrechnungen auf der IBM 3090E mit
   515	     Vektoreinrichtung.
   516	     Arbeitsbericht RRZK-8803, Regionales Rechenzentrum an der Universit"at zu
   517	     K"oln, Februar 1988
   518	[8]  McMahon, H.H.: The Livermore Fortran Kernels: A test of the numerical
   519	     performance range.
   520	     Technical Report UCRL-53745, Lawrence Livermore National
   521	     Laboratory, USA, December 1986
   522	[9]  Weicker, R.P.: Dhrystone: A Synthetic Systems Programming Benchmark.
   523	     Communications of the ACM, Vol. 27, No. 10, October 1984, pp. 1013-1030
   524	[10] Weicker, R.P.: Dhrystone Benchmark: Rationale for Version 2 and
   525	     Measurement Rules.
   526	     SIGPLAN Notices, Vol. 23, No. 8, August 1988, pp. 49-62
   527	[11] FasMath 83D87 Benchmark Report. Cyrix Corporation, June 1990
   528	     Order No. B2004
   529	[12] Doduc, Nhuan: Fortran Execution Time Benchmark.
   530	     Unpublished manuscript, version 45, available from ndoduc@framentec.fr
   531	