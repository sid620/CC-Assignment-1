     1	X-NEWS: hylka comp.sys.cbm: 9773
     2	Path: klaava!news.funet.fi!news.tele.fi!uunet!pipex!uknet!warwick!not-for-mail
     3	From: stuce@csv.warwick.ac.uk (Peter Weighill)
     4	Newsgroups: comp.sys.cbm
     5	Subject: 1541 disk drive commands.
     6	Date: 25 Sep 1993 19:20:47 +0100
     7	Organization: Commodore 64 Services, University of Warwick, UK
     8	Lines: 122
     9	Message-ID: <28225v$1s3@tansy.csv.warwick.ac.uk>
    10	
    11	
    12	TWO RARELY USED 1541 DISK DRIVE FUNCTIONS
    13	
    14	
    15	1. The Utility Loader '&' command.
    16	
    17	INTRODUCTION     
    18	
    19	     A little known and little used command on the 1541 disk drive is the
    20	"&" command. This is probably due to the fact that there is no mention of it
    21	in the "1541 DISK DRIVE users guide". Many other books about the disk drive
    22	also fail to mention it. As to a use for the command, I have not found one
    23	yet. Perhaps someone could think of one. I would expect that the 1570/1571
    24	and 1581 drive will also contain the "&" command as well, since they are
    25	based on the 1541.
    26	
    27	UTILITY LOADER  ("&" command)
    28	
    29	     The utility loader is the command which will load a USR file from
    30	disk into disk drive memory where it will then execute. The format for
    31	the command is as follows:
    32	OPEN15,8,15:PRINT#15,"&filename":CLOSE15
    33	
    34	USR FILES
    35	
    36	     A user file has to follow certain guidlines. It is limited to just
    37	one sector and this sector is constructed as below;
    38	
    39	Byte
    40	0      Start address low  order
    41	1      Start address high order
    42	2      Number of bytes in program
    43	3+     Program code bytes
    44	last   Checksum
    45	
    46	     This means that the maximum size of program code is 251 bytes. The
    47	checksum byte is calculated by adding all the values of the bytes, starting
    48	at the low order start address (byte 0), while adding you subtract 255 from
    49	the total every time it exceeds 255. Thus the checksum byte can range from
    50	1-255.
    51	     One final constraint is that the filename must begin with an "&".
    52	     Below is a program which will make it easier for you to create a USR
    53	file in the required format, so that it can be executed by the utility
    54	loader command. The program automatically calculates the length of the code
    55	and also the checksum at the end. All you need to do is add your own code
    56	to the data statements between 210 and 300 and specify a filename in line 10.
    57	
    58	10  OPEN2,8,2,"0:&filename,U,W"
    59	20  READLO,HI:C=LO+HI:IFC>255THENC=C-255
    60	30  PRINT#2,CHR$(LO)CHR$(HI);
    61	40  T$=""
    62	50  READD:IFD=-1THEN100
    63	60  C=C+D:IFC>255THENC=C-255
    64	70  T$=T$+CHR$(D)
    65	80  GOTO50
    66	100 L=LEN(T$)
    67	110 C=C+L:IFC>255THENC=C-255
    68	120 PRINT#2,CHR$(L)T$CHR$(C);
    69	130 CLOSE2
    70	140 END
    71	170 :
    72	200 DATA 0,5 :REM lo/hi start address
    73	210 :         REM program code
    74	220 DATA 173,0,28,41,16,201,16,208,11
    75	230 DATA 169,247,45,0,28,141,0,28,76
    76	240 DATA 0,5,32,24,193,76,0,5
    77	300 DATA -1  :REM program data finished
    78	
    79	     The example code in the program is not that useful, it is just there
    80	to show how the utility loader works. It just switches the drives light on
    81	and off depending on if the write protect sensor is covered or not.
    82	     If you can think of something which could be done with the utility
    83	loader then I would love to hear of it.
    84	
    85	ERRORS THAT CAN OCCUR
    86	
    87	39, 'file not found'
    88	        This occurs if the file you specified using the utility loader
    89	        command does not exist or is not a USR file.
    90	
    91	50, 'record not present'  
    92	        The checksum calculated by the disk drive and the checksum at the
    93	        end of the file differ.
    94	
    95	51, 'overflow in record'
    96	        Either: 1. The end of the file was reached before the checksum
    97	                   byte was read.
    98	        or      2. The file contains extra bytes of data after the checksum
    99	                   byte.
   100	        Check the length byte in the usr file (position 3, after lo/hi.)
   101	
   102	
   103	
   104	2. Checking that a file is on the disk.
   105	
   106	INTRODUCTION
   107	
   108	     If you wrote a program which needed to check that a particular file
   109	existed on a disk then you would probably open the file for a read, then
   110	check the error channel for 62, FILE NOT FOUND.
   111	
   112	Thus:
   113	10 OPEN15,8,15
   114	20 OPEN2,8,2,"filename,P,R"
   115	30 INPUT#15,E,E$
   116	40 IFE>0THENPRINTE$:GOTO60
   117	50 PRINT"FILE EXISTS"
   118	60 CLOSE2:CLOSE15
   119	
   120	     Another way to check if a file exists is to try to rename it as itself.
   121	
   122	Thus:
   123	10 OPEN15,8,15,"R:filename=filename"
   124	20 INPUT#15,E,E$
   125	30 CLOSE15
   126	40 PRINTE$
   127	
   128	     If the file exists then the error created is 63, FILE EXISTS,
   129	otherwise it is 62, FILE NOT FOUND. Judge for yourself which works better.
   130	
   131	
   132	Written, September 93, by Peter Weighill.   email: stuce@warwick.csv.ac.uk
   133	
   134	
   135	
   136	From: Nicholas.Cull@comp.vuw.ac.nz (Nicholas Cull)
   137	Newsgroups: comp.sys.cbm
   138	Subject: Re: 1541 disk drive commands.
   139	Date: 30 Sep 1993 00:00:20 GMT
   140	Organization: Dept. of Comp. Sci., Victoria Uni. of Wellington, New Zealand.
   141	Originator: ncull@comp.vuw.ac.nz
   142	
   143	
   144	In article <28225v$1s3@tansy.csv.warwick.ac.uk>, stuce@csv.warwick.ac.uk
   145	 (Peter Weighill) writes:
   146	|> 
   147	|> 1. The Utility Loader '&' command.
   148	
   149	...
   150	
   151	|>      A user file has to follow certain guidlines. It is limited to just
   152	                                                     ^^^^^^^^^^^^^^^^^^^^^
   153	|> one sector and this sector is constructed as below;
   154	   ^^^^^^^^^^
   155	
   156	This is incorrect. The user file may be more than one sector long, although the
   157	maximum size of the program code is limited to 256 bytes. To obtain this, byte
   158	2 (the number of bytes in program) should be set to 0. A formula for this
   159	would be
   160	
   161	(NB AND 255)
   162	
   163	where NB is the number of bytes. Remember that the checksum has to be updated
   164	in a similar way too, eg
   165	
   166	 C = C+(NB AND 255): IF C>255 THEN C=C-255
   167	
   168	The number of bytes in a Block-Execute command is limited to a single sector,
   169	which is 256 bytes, although these can be all data bytes. Maybe you were
   170	confusing the two commands?
   171	
   172	|> 
   173	|> Byte
   174	|> 0      Start address low  order
   175	|> 1      Start address high order
   176	|> 2      Number of bytes in program
   177	|> 3+     Program code bytes
   178	|> last   Checksum
   179	|> 
   180	
   181	In fact there can be more than one block of this construction per file. To do
   182	this, simply repeat the construction. For example, if you wanted to have a
   183	program which sat in drive locations $0300 to $0400, and $0480 to $0500, the
   184	construction would be as follows:
   185	
   186	Byte
   187	0             Low byte start address of first block (0)
   188	1             High byte start address of first block (3)
   189	2             Number of bytes in this block (0)        [= 256 AND 255]
   190	3 - 259       Program code for first block (data goes in here...)
   191	260           Checksum for first block (whatever this may be)
   192	
   193	261           Low byte start address of second block (128)
   194	262           High byte start address of second block (4)
   195	263           Number of bytes in this block (128)
   196	264 - 392     Program code for second block (second lot of data here)
   197	393           Checksum for second block (whatever)
   198	
   199	Okay, so this may not be the best description in the world, but hopefully you
   200	get the general idea. There may be as many blocks of this type as you need,
   201	and theycan all be any size from 1 to 256 bytes long. Once the file has been
   202	completely loaded into the drive, execution starts from the start address of
   203	the FIRST block be be transferred.
   204	
   205	|> the total every time it exceeds 255. Thus the checksum byte can range from
   206	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   207	|> 1-255.
   208	   ^^^^^^
   209	
   210	The checksum could be 0 if all the data bytes were 0 :-)
   211	
   212	Seriously though, the point of having the checksum calculated in this way is to
   213	make use of the carry bit in machine code addition if a carry is generated. The
   214	point can be made more clearly in the following code fragment:
   215	
   216	        [accumulator holds current data byte]
   217	        clc        ;Clear carry bit for first add
   218	        adc $87    ;Add byte to current checksum
   219	        adc #$00   ;Add carry bit to checksum
   220	        sta $87    ;Save checksum to memory
   221	
   222	If the sum of the accumulator and the contents of location $87 is greater than
   223	#$FF then the carry flag will be set, in order to do multi-byte addition
   224	correctly. Instead of adding this to a second byte however, it is added to the
   225	same byte which generated the carry. This causes the value in the accumulator
   226	to be incremented by 1 - the same as if #$FF had been subtracted from it.
   227	
   228	If the sum is of the accumulator and the contents of location $87 is less than
   229	or equal to #$FF, then no carry is generated and no further addition or
   230	subtractionis needed.
   231	
   232	|>      Below is a program which will make it easier for you to create a USR
   233	|> file in the required format, so that it can be executed by the utility
   234	|> loader command...
   235	
   236	Here is a new version the the program, modified to handle multiple data blocks,
   237	and a maximum program size of 256 bytes per block:
   238	
   239	        10  OPEN2,8,2,"0:&filename,U,W"
   240	        20  READNB
   241	        30  READLO,HI,LN:C=LO+HI:C=C+(C>255)*255
   242	        40  C=C+(LNAND255):C=C+(C>255)*255
   243	        50  PRINT#2,CHR$(LO);CHR$(HI);CHR$(LNAND255);
   244	        60  READD:PRINT#2,CHR$(D);
   245	        70  C=C+D:C=C+(C>255)*255
   246	        80  LN=LN-1:IFLN>0THEN60
   247	        90  PRINT#2,CHR$(C);
   248	        100 NB=NB-1:IFNB>0THEN30
   249	        110 CLOSE2
   250	        120 END
   251	        190 :
   252	        200 DATA2       :REM number of data blocks
   253	        210 DATA128,3   :REM lo/hi start address of first block
   254	        220 DATA6       :REM length of first block
   255	        230 :            REM program code
   256	        240 DATA32,71,198,76,0,3
   257	        300 DATA0,3     :REM lo/hi start address of second block
   258	        310 DATA26      :REM length of second block
   259	        320 :            REM rest of program code
   260	        330 DATA173,0,28,41,16,201,16,208,11
   261	        340 DATA169,247,45,0,28,141,0,28,76
   262	        350 DATA0,3,32,24,193,76,0,3
   263	
   264	The example code here is just a minor extension to the original code. It
   265	re-initializes the drive before jumping to the original code. This is just to
   266	demonstrate that both parts of the code are being loaded and executed
   267	correctly. 
   268	
   269	|> ERRORS THAT CAN OCCUR
   270	|> 
   271	|> 51, 'overflow in record'
   272	|>         Either: 1. The end of the file was reached before the checksum
   273	|>                    byte was read.
   274	|>         or      2. The file contains extra bytes of data after the checksum
   275	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   276	|>                    byte.
   277	                      ^^^^^
   278	|>         Check the length byte in the usr file (position 3, after lo/hi.)
   279	
   280	The second condition is not quite accurate. If end-of-file is reached before
   281	the drive expects to read the checksum, then this error will occur. If extra
   282	bytes appear after the checksum, the drive assumes these to be the start of a
   283	new block of data and will try to interpret these as address bytes, length
   284	byte, data bytes etc as above. When end-of-file appears, the drive will report
   285	this error, since it is expecting another block of data to appear and cannot
   286	complete the transfer of this into memory. Hence the definition of this error
   287	should be:
   288	
   289	        The end of the file was encountered unexpectedly. May indicate an
   290	        incorrect length byte, or additional data written after the end of the
   291	        last data block.
   292	
   293	Note the semicolon at the end of line 90 of the program. If this were omitted,
   294	a carriage return byte would be sent by the computer after the checksum byte
   295	and may be the cause of this message.
   296	
   297	One caution should be added at this point. Although data may be transferred to
   298	any address in the RAM of the drive, it should be remembered that part of the
   299	memory will be allocated to buffering the file as it comes off the disk. Thus
   300	it may be possible to overwrite incoming data being buffered in memory before
   301	it can be transferred correctly to its new location. Experimentation may be
   302	the best way of determining which areas are "safe" and which ones have
   303	problems. I found that the file seemed to be buffered in locations $0600 to
   304	$0700, but this would depend on how may files you had open, etc.
   305	
   306	Nick.
   307	
   308	----
   309	 email: ncull@comp.vuw.ac.nz    Victoria University of Wellington, New Zealand.
   310	
