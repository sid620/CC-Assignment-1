     1	From: pegram@uvm-gen.UUCP (Robert B. Pegram)
     2	Newsgroups: comp.sys.atari.st.tech
     3	Subject: How to upgrade your ST floppies to 1.44Meg 3.5" drives
     4	Date: 18 Jul 90 16:14:16 GMT
     5	Sender: nobody@uvm-gen.UUCP
     6	Organization: EMBA Computer Facility, Univ. of Vermont, Burlington.
     7	
     8	
     9	Tried to post this yesterday from GnuEmacs - no go.  Here it is,
    10	Hartmut Semken(AKA hase)'s 1.44 meg Upgrade for Atari STs and Megas.
    11	This is a compilation of several postings, edited by Bob Pegram, my
    12	comments are indicated by  [..text..] <- RBPIII.  I have yet to do the
    13	upgrade myself (lazy 8-), but it seems workable.  From the TT rumor 
    14	about no HD floppy for now, it would seem that Atari is doing the same 
    15	thing, only with a new (not yet fully available) floppy controller from 
    16	Western Digital that *is rated* to handle the higher clock input that is
    17	necessary.  Thus, in the future, this upgrade may become a more reliable 
    18	and simple chip replacement.  Enjoy,
    19	Bob Pegram
    20	
    21	originally From: hase@hase_1.UUCP (Hartmut Semken)
    22	original Subject: Re: Floppy drive 1.44 meg woes!
    23	original Date: 11 Feb 90 09:55:00 GMT
    24	 References: <9002030029.AA23185@jade.berkeley.edu> <2103@ultb.isc.rit.edu>
    25	 Organization: h.a.s.e., Berlin, West Germany
    26	
    27	
    28	clf3678@ultb.isc.rit.edu (C.L. Freemesser) writes:
    29	
    30	 Reply-To: hase@netmbx.UUCP (Hartmut Semken)
    31	 Organization: netmbx Public Access Unix, Berlin, West Germany
    32	 Lines: 28
    33	 Posted: Sat Nov 25 17:57:46 1989
    34	
    35	
    36	>>  I'm having a few problems hooking up my 1.44 meg teac. I was wondering
    37	> From what I know, you can't use HD on the ST.  The controller chip
    38	>can't handle it.  Just be glad it works in 720k mode.  :^)
    39	
    40	Well, you can, if you hack the hardware.
    41	
    42	Here we go again:
    43	
    44	The trick is to double the clock frequency of the controller chip, so it
    45	will talk twice as fast to the drive: the bit stream has "high-density"
    46	format.
    47	A clock of 16 MHz is well beyond specification (the WD1772 is rated to
    48	run at up to 10 MHz), but it will work most of the time.
    49	
    50	The hack consists of two parts: hardware and software and works with
    51	( [3.5 inch] <- RBPIII ) high density drives only!
    52	
    53	[The reason being that the drive must auto-sense the HD disk when it is 
    54	 inserted and change its RPMs up accordingly.  5.25 (1.2Meg) drives do 
    55	 *not* do this!  Neither do all HD 3.5" floppies (notably the ones on 
    56	 true blue PS 2 s). ] <- RBPIII
    57	 
    58	Now: the hardware.
    59	
    60	The clock pin of the WD1772 is pin 18. It is normally hooked to the 8
    61	MHz clock.
    62	Cut this pin and connect it to the output of a simple circuit. feed the
    63	two inputs of this simple circuit with 8 MHz and 16 MHz clocks (16 MHz
    64	can be gotten at SHIFTER pin 39).
    65	The "simple circuit" mentioned above could be a simple, manual switch.
    66	Now You are able to select two clock frequencies and therfore two
    67	"modes" for the controller chip: double density and high density.
    68	
    69	The simple circuit could also be a multiplexer (74LS157, I think)
    70	controlled by the "I detected a HD-disk in me"-output of the floppy
    71	drive (the TEAC FD 235 HFN provides this outout on pin 2 if a jumper is
    72	set; the 235 HFN has a second jumper that enables internal detection of
    73	HD disks: this must be set, too).
    74	With the MUX, a disk inserted will select the appropriate mode of
    75	operation automatically.
    76	
    77	Do not worry about two drives in different modes: when copying from one
    78	drive to the other, the clock rate will be switched once to twice a
    79	second. This will not trouble the controller (remember the clock to be
    80	in the range of Megahertz...).
    81	If you want to connect one HD drive and one DD drive, you'll need two
    82	more TTL gates (one 74LS00 will do) to make sure, the controller is in
    83	DD mode for the DD only drive: invert the HD-detected-output (it is LOW
    84	for DD before, HIGH for DD behind the inverter) and feed it into a NAND
    85	gate together with drive select for the DD drive. Let a HIGH output of the
    86	NAND gate select DD-clock (8 MHz). Now "not-HD-detected OR DD-drive-select"
    87	will select DD mode, right?
    88	
    89	With two HD drives, there is no problem at all :-) [except for the 
    90	High Density floppy boot problem, discussed below.  You have to set 
    91	the step rate from the boot sector.] <- RBPIII
    92	
    93	Now for the software:
    94	
    95	The controller uses its clock as base for all timings.
    96	The pulse width and time between pulses for the step line are controller
    97	controlled.                                                   ^^^^^^^^^
    98	                                                       [WD 1772] <- RBPIII
    99	To make it short: with the doubled clock the controller will try to make
   100	the head step twice as fast: he will send a step pulse every 1.5
   101	milliseconds if set to 3 milliseconds (which is TOS standard).
   102	Just set the step rate to 6 milliseconds to make the controller step 3
   103	milliseconds in HD mode (well, the 6 milliseconds steps in DD mode will
   104	slow down floppy operation a bit, but not that much. Not stepping, [but]
   105	reading and writing takes the time!).
   106	
   107	How to set the step rate?
   108	Well, there is a documented TOS variable for the step rate at 0x440
   109	called seekrate.
   110	The step rate in this variable will be used by the BIOS after a call of
   111	the routine, pointed to by "hdv_init" (the hdv_init routine seems to
   112	initialize the BIOS parameter blocks for the floppies). The pointer to
   113	hdv_init can be found at 0x46A (this is a supported TOS variable, too).
   114	Look at the MWC-Assembler source below.
   115	
   116	[More information on the step rate from another posting - between the 
   117	curly braces below] <- RBPIII
   118	
   119	{
   120	 In article <1346@uvm-gen.UUCP> pegram@uvm-gen.UUCP (pegram r) writes:
   121	 >
   122	 >Rats! I looked up the possible seek rates last night, 6 msec is as slow
   123	 >as she goes. 
   124	
   125	 Hmm, TOS will step at 6,12,2,3 msec (with rate codes 0,1,2,3).
   126	 Setting the controller to 6 msec and doubling the clock works for almost
   127	 all 3.5 inch HD drives.
   128	
   129	 [I wanted to know if you could still use a (360 K) 5.25 drive, which 
   130	 needs a true 6 msec step rate.  This was when no WD 1772 clock switching 
   131	 (between 8 and 16 Mhz) was contemplated.  If your 1772 works this 
   132	 fast, you can forget the switch, or use a properly buffered manual 
   133	 switch for those rare occasions when it's necessary.  "Properly buffered"
   134	 you ask?  See any of the usual designs that eliminate switch bounce -
   135	 Radio Shack's pamphlets on digital electronics have the circuits needed.
   136	 The 74LS00 mentioned above will work nicely as the debouncer and "glue".
   137	 You still want that Multiplexer and you send in the debounced 16Mhz ("On" 
   138	 or "TRUE") and 8Mhz (The inverted "FALSE" or "OFF") outputs from the manual 
   139	 switch to select the clocks.  That is just a design off the top of my
   140	 head, which needs to be improved.  Please do post a better one if you
   141	 come up with one, I can think of a one chip (the LS00) solution if
   142	 clock skew to the WD1772 is unimportant (as in 180 degrees out of
   143	 phase 8-). The reason I mention it is because, I believe that the 
   144	 problem mentioned at the beginning of the original posting was due to 
   145	 either an incorrect jumper setting on the drive, or a noise problem 
   146	 in the ST, having the clocks going all over the ST to the switch, 
   147	 is not a good idea at all!  You don't have to worry about driving 
   148	 more capacitance with such free standing wires, but you do have to 
   149	 think about the effect of having some new high frequency antennas 
   150	 inside your ST!] <- RBPIII
   151	
   152	 >It would also be hard to boot from a floppy with this
   153	 >mod (double - 16Mhz - clock for 1772 + formatter + "6"msec seek rate).
   154	 >Do you have to have a seek rate setting boot sector on every boot
   155	 >floppy and would that idea even work?
   156	
   157	 Sure, that should work, since no steps schould be necessary to read the
   158	 boot sector.
   159	 I boot from harddisk...
   160	
   161	 [Me too, but some utilities (DC formatter at least) can format disks 
   162	  with boot sectors that can reset the step rate on boot up. Game disks
   163	  could be similarly hacked to work with the new drive.] <- RBPIII
   164	
   165	 If the HD-floppy does not work after modifying the ST, the step pulse
   166	 width is a probable cause.
   167	 In that case, use an edge-triggered monoflop to "resize" the pulse.
   168	                                     ^^^^^^^^
   169	 [hase means a monostable or "one-shot" available in TTL or with the "555"
   170	  timer chip.] <- RBPIII  
   171	}
   172	
   173	The second thing is to get a formatter that will format 18 sectors per
   174	track. HYPERFORMAT by Claus Brodt is such a thing, but a simple
   175	formatter hacked from the example in the Mark Williams C Lexicon did the
   176	same. It's included below.
   177	
   178	
   179	For help try to write to hase@hase_1.mbx.sub.org, but it'll probably
   180	bounce; our mail service is fading fast... 
   181	
   182	[Check if hase's current address is the same, he does show up on c.s.a.s] 
   183	<- RBPIII
   184	
   185	I'll try to reply to anything, I finally get.
   186	
   187	hase
   188	
   189	------- cut for seek6.s -----------
   190	/module name seek6
   191	
   192	.shri
   193	
   194	.globl main_
   195	main_:
   196	clr.l-(sp)
   197	move.w$0x20,-(sp)
   198	trap$1
   199	addq.l$6,a7
   200	move.ld0,_save_ssp
   201	move.w$0,0x440/ 0 => 6 ms
   202	lea0x46a,a0
   203	move.l(a0),d0
   204	movea.ld0,a0
   205	jsr(a0)
   206	move.l_save_ssp,-(sp)
   207	move.w$0x20,-(sp)
   208	trap$1
   209	addq.l$6,a7
   210	.even
   211	_save_ssp:
   212	.blkl1
   213	/ seek rate codes are 0,1,2,3 for 6,12,2,3 milliseconds
   214	
   215	Sets seek rate to 6 Milliseconds for *all* drives (with *any* TOS
   216	version; tested on Rainbow TOS (1.4), BLiTTER TOS (1.2) and TOS 1.0):
   217	
   218	------------ cut for formath.c -------------
   219	
   220	/* formath.c Formatter fuer High Density Disketten */
   221	/* nur fuer angepasste Hardware! Floppycontroller und Laufwerk */
   222	/* muessen High-Density tauglich sein! */
   223	/* Hartmut Semken, Lupsteiner Weg 67 1000 Berlin 37 */
   224	/* hase@hase_1.mbx.sub.org or hase@netmbx.mbx.sub.org */
   225	/* 03-SEP-89 */
   226	#include <stdio.h>
   227	#include <osbind.h>
   228	#include <time.h>
   229	
   230	#define SLEEPTIME 1/* 1: Zeitschleife, 0: Taste */
   231	#define BLANK (0xE5E5)
   232	#define MAGIC (0x87654321L)
   233	#define BUFSIZE (20*1024) /* Platz fuer mehr als 18 Sektoren... */
   234	
   235	#define DEVICE 0/* 0 = Floppy A, 1 = Floppy B*/
   236	#define SIDES 2/* je  */
   237	#define SECTORS 18/* nach*/
   238	#define TRACKS 80/*Belieben*/
   239	
   240	#define TOTSEC (TRACKS * SIDES * SECTORS)
   241	
   242	extern int errno;
   243	
   244	main(){
   245	int track;
   246	int side;
   247	int status;
   248	short *bf;
   249	register char reply;
   250	short *middle;
   251	char buffer[512];
   252	
   253	printf("\033E\n");
   254	printf("Public Domain High Density Mini Formatter\n");
   255	printf("von H. Semken\nDer Autor garantiert in keiner Weise fr die Funktion\nDi
   256	eses Programmes.\nBenutzung auf eigene Gefahr.\n");
   257	printf("\n\n\n");
   258	printf("\007\033pFormatiere Diskette in Drive %c\033q\n%d Seiten\n%d Sektoren p
   259	ro Spur\n%d Spuren\n\n", (65+DEVICE), SIDES, SECTORS, TRACKS);
   260	printf("Wirklich formatieren? ");
   261	fflush(stdout);
   262	if ((reply = Crawcin()) != 'y' && reply != 'Y' && reply != 'j' && reply != 'J')
   263	 {
   264	printf("Nein. Floppy nicht formatiert.\n");
   265	sleep(1);
   266	Pterm0();
   267	}
   268	printf("Ja.\n");
   269	printf("Diskette einlegen; Taste drcken...");
   270	fflush(stdout);
   271	Crawcin();
   272	printf("\n");
   273	bf = malloc(BUFSIZE);
   274	for (track = TRACKS-1; track >= 0; track--) {
   275	for (side = 0; side < SIDES; side++) {
   276	printf("Formatiere Spur %d, Seite %d", track, side);
   277	fflush(stdout);
   278	status = Flopfmt(bf, 0L, DEVICE, SECTORS, track, side, 1, MAGIC, BLANK);
   279	if (status) {
   280	middle = bf;
   281	printf("\t%d\n", status);
   282	while (*middle) {
   283	printf("\tDefekter Sektor %d\n", *middle++);
   284	}
   285	} else {
   286	printf("\tokay\r");
   287	}
   288	}
   289	}
   290	printf("\n\nAlle Spuren formatiert\n");
   291	printf("Initialisiere Directory\n");
   292	for (track = 0; track < (BUFSIZE>>1); bf[track++] = 0);
   293	for (track = 0; track < 2;track++) {
   294	for (side = 0; side < SIDES; side++){
   295	if (status = Flopwr(bf, 0L, DEVICE, 1, track, side, SECTORS)) {
   296	errno = -status;
   297	perror("Write Error");
   298	}
   299	}
   300	}
   301	Protobt(buffer, (long)Random(),3,0); /* Prototyp Bootsector fr 
   302	                                      * 80 * 2 * 9 Sektoren */
   303	/* Prototyp Bootsektor fr das neue Format anpassen */
   304	/* Bytes 19 und 20 enthalten die Sektoren pro Disk */
   305	
   306	/* unteres Byte von TOTSEC */
   307	buffer[19] = (char)(((TOTSEC>>8)<<8)^TOTSEC);
   308	/* oberes Byte von TOTSEC; es lebe das Intel int-Format */
   309	buffer[20] = (char)(TOTSEC>>8);
   310	buffer[24] = (char)SECTORS; /* Sektoren pro Spur */
   311	status = Flopwr(buffer, 0L, DEVICE, 1, 0, 0, 1);
   312	if (status) {
   313	errno = -status;
   314	perror("Write Error (Bootsector)");
   315	}
   316	status = Flopver(buffer, 0L, DEVICE, 1, 0, 0, 1);
   317	if (status) {
   318	errno = -status;
   319	perror("Verify Error (Bootsector)");
   320	}
   321	printf("Diskette in Laufwerk %c formatiert\n", (65+DEVICE));
   322	sleep(1);
   323	Pterm0();
   324	}
   325	
   326	sleep(seconds)
   327	int seconds;
   328	#if SLEEPTIME
   329	{
   330	clock_t t;
   331	for(t = clock();clock() < (t + CLK_TCK*seconds););
   332	}
   333	#else
   334	{
   335	printf("Taste druecken\n");
   336	fflush(stdout);
   337	Crawcin();
   338	}
   339	#endif
   340	-- 
   341	original idea and post by:
   342	
   343	>Hartmut Semken, Lupsteiner Weg 67, 1000 Berlin 37 hase@hase_1.UUCP
   344	>Dennis had stepped up into the top seat whet its founder had died of a
   345	>lethal overdose of brick wall, taken while under the influence of a
   346	>Ferrari and a bottle of tequila. (Douglas Adams; the long dark teatime...)
   347	
   348	Additions by:
   349	
   350	Bob Pegram   Internet: pegram@griffin.uvm.edu
   351	     UUCP: you figure it out!
   352	     Physical Mail: R. Pegram, R.R. #2, Box 2843, Green St.,
   353	    Vergennes, Vt. 05491, U.S.A.
   354	     Home Tel: (in N.A., add appropriate codes if elsewhere)
   355	 (802) 877 0018
   356	
   357	
   358	
